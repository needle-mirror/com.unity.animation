// This file is generated. Do not modify by hand.
// XML documentation file not found. To check if public methods have XML comments,
// make sure the XML doc file is present and located next to the scraped dll
namespace Unity.Animation
{
    public struct AffineTransform : System.IEquatable<Unity.Animation.AffineTransform>, System.IFormattable
    {
        public static readonly Unity.Animation.AffineTransform identity;
        public Unity.Mathematics.float3x3 rs;
        public Unity.Mathematics.float3 t;
        public AffineTransform(Unity.Mathematics.float3x3 m) {}
        public AffineTransform(Unity.Mathematics.float3x4 m) {}
        public AffineTransform(Unity.Mathematics.float4x4 m) {}
        public AffineTransform(Unity.Mathematics.RigidTransform rigid) {}
        public AffineTransform(Unity.Mathematics.float3 t, Unity.Mathematics.float3x3 rs) {}
        public AffineTransform(Unity.Mathematics.float3 t, Unity.Mathematics.quaternion r) {}
        public AffineTransform(Unity.Mathematics.float3 t, Unity.Mathematics.quaternion r, Unity.Mathematics.float3 s) {}
        public virtual bool Equals(object x);
        public virtual bool Equals(Unity.Animation.AffineTransform x);
        public virtual int GetHashCode();
        public static Unity.Mathematics.float3x4 op_Implicit(Unity.Animation.AffineTransform m);
        public static Unity.Mathematics.float4x4 op_Implicit(Unity.Animation.AffineTransform m);
        public virtual string ToString();
        public virtual string ToString(string format, System.IFormatProvider formatProvider);
    }

    public struct AnimatedData : Unity.Entities.IBufferElementData
    {
        public float Value;
    }

    public struct AnimatedLocalToRoot : Unity.Entities.IBufferElementData
    {
        public Unity.Mathematics.float4x4 Value;
    }

    public struct AnimatedLocalToWorld : Unity.Entities.IBufferElementData
    {
        public Unity.Mathematics.float4x4 Value;
    }

    [Unity.Entities.WriteGroup(typeof(Unity.Transforms.LocalToParent))] public struct AnimationLocalToParentOverride : Unity.Entities.IComponentData
    {
    }

    [Unity.Entities.WriteGroup(typeof(Unity.Transforms.LocalToWorld))] public struct AnimationLocalToWorldOverride : Unity.Entities.IComponentData
    {
    }

    [System.Diagnostics.DebuggerTypeProxy(typeof(Unity.Animation.AnimationStreamDebugView))] public struct AnimationStream
    {
        public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> Rig;
        public int DataChunkCount { get; }
        public int FloatCount { get; }
        public int IntCount { get; }
        public bool IsNull { get; }
        public static Unity.Animation.AnimationStream Null { get; }
        public int RotationChunkCount { get; }
        public int RotationCount { get; }
        public int ScaleCount { get; }
        public int TranslationCount { get; }
        public void AndChannelMasks(ref Unity.Animation.AnimationStream other);
        public void AndChannelMasks(ref Unity.Animation.AnimationStream lhs, ref Unity.Animation.AnimationStream rhs);
        public void ClearChannelMasks();
        public void CopyChannelMasksFrom(ref Unity.Animation.AnimationStream src);
        public static Unity.Animation.AnimationStream Create(Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rig, Unity.Collections.NativeArray<Unity.Animation.AnimatedData> buffer);
        public static Unity.Animation.AnimationStream CreateReadOnly(Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rig, Unity.Collections.NativeArray<Unity.Animation.AnimatedData> buffer);
        public static Unity.Animation.AnimationStream FromDefaultValues(Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rig);
        public int GetChannelMaskBitCount();
        public Unity.Mathematics.float4* GetDataChunkUnsafePtr();
        public float GetFloat(int index);
        public bool GetFloatChannelMask(int index);
        public int GetInt(int index);
        public bool GetIntChannelMask(int index);
        public Unity.Animation.AffineTransform GetLocalToParentInverseMatrix(int index);
        public Unity.Animation.AffineTransform GetLocalToParentMatrix(int index);
        public Unity.Mathematics.quaternion GetLocalToParentRotation(int index);
        public Unity.Mathematics.float3 GetLocalToParentScale(int index);
        public void GetLocalToParentTR(int index, out Unity.Mathematics.float3 translation, out Unity.Mathematics.quaternion rotation);
        public Unity.Mathematics.float3 GetLocalToParentTranslation(int index);
        public void GetLocalToParentTRS(int index, out Unity.Mathematics.float3 translation, out Unity.Mathematics.quaternion rotation, out Unity.Mathematics.float3 scale);
        public Unity.Animation.AffineTransform GetLocalToRootInverseMatrix(int index);
        public Unity.Animation.AffineTransform GetLocalToRootMatrix(int index);
        public Unity.Mathematics.quaternion GetLocalToRootRotation(int index);
        public Unity.Mathematics.float3 GetLocalToRootScale(int index);
        public void GetLocalToRootTR(int index, out Unity.Mathematics.float3 translation, out Unity.Mathematics.quaternion rotation);
        public Unity.Mathematics.float3 GetLocalToRootTranslation(int index);
        public void GetLocalToRootTRS(int index, out Unity.Mathematics.float3 translation, out Unity.Mathematics.quaternion rotation, out Unity.Mathematics.float3 scale);
        public bool GetRotationChannelMask(int index);
        public Unity.Animation.quaternion4* GetRotationChunkUnsafePtr();
        public bool GetScaleChannelMask(int index);
        public bool GetTranslationChannelMask(int index);
        public void* GetUnsafePtr();
        public bool HasAllChannelMasks();
        public bool HasAnyChannelMasks();
        public bool HasNoChannelMasks();
        public void OrChannelMasks(ref Unity.Animation.AnimationStream other);
        public void OrChannelMasks(ref Unity.Animation.AnimationStream lhs, ref Unity.Animation.AnimationStream rhs);
        public void SetChannelMasks(bool value);
        public void SetFloat(int index, ref float value);
        public void SetInt(int index, ref int value);
        public void SetLocalToParentRotation(int index, ref Unity.Mathematics.quaternion rotation);
        public void SetLocalToParentScale(int index, ref Unity.Mathematics.float3 scale);
        public void SetLocalToParentTR(int index, ref Unity.Mathematics.float3 translation, ref Unity.Mathematics.quaternion rotation);
        public void SetLocalToParentTranslation(int index, ref Unity.Mathematics.float3 translation);
        public void SetLocalToParentTRS(int index, ref Unity.Mathematics.float3 translation, ref Unity.Mathematics.quaternion rotation, ref Unity.Mathematics.float3 scale);
        public void SetLocalToRootRotation(int index, ref Unity.Mathematics.quaternion rotation);
        public void SetLocalToRootScale(int index, ref Unity.Mathematics.float3 scale);
        public void SetLocalToRootTR(int index, ref Unity.Mathematics.float3 translation, ref Unity.Mathematics.quaternion rotation);
        public void SetLocalToRootTranslation(int index, ref Unity.Mathematics.float3 translation);
        public void SetLocalToRootTRS(int index, ref Unity.Mathematics.float3 translation, ref Unity.Mathematics.quaternion rotation, ref Unity.Mathematics.float3 scale);
    }

    public static class AnimationStreamUtils
    {
        public static void MemClear(ref Unity.Animation.AnimationStream stream);
        public static void MemCpy(ref Unity.Animation.AnimationStream dst, ref Unity.Animation.AnimationStream src);
        public static void SetDefaultValues(ref Unity.Animation.AnimationStream stream);
    }

    [System.Obsolete(@"AnimationTransformOverride has been deprecated. Use AnimationLocalToParentOverrideand AnimationLocalToWorldOverride instead. (RemovedAfter 2020-08-26)")] [Unity.Entities.WriteGroup(typeof(Unity.Transforms.LocalToParent))] [Unity.Entities.WriteGroup(typeof(Unity.Transforms.LocalToWorld))] public struct AnimationTransformOverride : Unity.Entities.IComponentData
    {
    }

    public struct Axis
    {
        public Unity.Mathematics.quaternion PostRotation;
        public Unity.Mathematics.quaternion PreRotation;
        public Unity.Mathematics.float3 RotationOffset;
        public Unity.Mathematics.float3 RotationPivot;
        public Unity.Mathematics.float3 ScalingOffset;
        public Unity.Mathematics.float3 ScalingPivot;
    }

    public struct BindingSet
    {
        public Unity.Entities.BlobArray<Unity.Animation.StringHash> FloatBindings;
        public static readonly int FloatKeyFloatCount;
        public Unity.Entities.BlobArray<Unity.Animation.StringHash> IntBindings;
        public static readonly int IntKeyFloatCount;
        public Unity.Entities.BlobArray<Unity.Animation.StringHash> RotationBindings;
        public static readonly int RotationKeyFloatCount;
        public Unity.Entities.BlobArray<Unity.Animation.StringHash> ScaleBindings;
        public static readonly int ScaleKeyFloatCount;
        public Unity.Entities.BlobArray<Unity.Animation.StringHash> TranslationBindings;
        public static readonly int TranslationKeyFloatCount;
        public int BindingCount { get; }
        public int ChannelMaskOffset { get; }
        public int ChannelSize { get; }
        public int CurveCount { get; }
        public int DataChunkCount { get; }
        public int FloatBindingIndex { get; }
        public int FloatCurveCount { get; }
        public int FloatSamplesOffset { get; }
        public int IntBindingIndex { get; }
        public int IntCurveCount { get; }
        public int IntSamplesOffset { get; }
        public int RotationBindingIndex { get; }
        public int RotationChunkCount { get; }
        public int RotationCurveCount { get; }
        public int RotationSamplesOffset { get; }
        public int ScaleBindingIndex { get; }
        public int ScaleCurveCount { get; }
        public int ScaleSamplesOffset { get; }
        public int StreamSize { get; }
        public int TranslationBindingIndex { get; }
        public int TranslationCurveCount { get; }
        public int TranslationSamplesOffset { get; }
    }

    public struct BindPose : Unity.Entities.IBufferElementData
    {
        public Unity.Mathematics.float4x4 Value;
    }

    public struct BlendTree1D
    {
        public Unity.Animation.StringHash BlendParameter;
        public Unity.Entities.BlobArray<Unity.Animation.Motion> Motions;
        public Unity.Entities.BlobArray<float> MotionSpeeds;
        public Unity.Entities.BlobArray<float> MotionThresholds;
    }

    public struct BlendTree1DMotionData : System.IComparable<Unity.Animation.BlendTree1DMotionData>, Unity.Entities.IBufferElementData
    {
        public Unity.Animation.Motion Motion;
        public float MotionSpeed;
        public float MotionThreshold;
        public virtual int CompareTo(Unity.Animation.BlendTree1DMotionData other);
        public static bool operator >(Unity.Animation.BlendTree1DMotionData operand1, Unity.Animation.BlendTree1DMotionData operand2);
        public static bool operator >=(Unity.Animation.BlendTree1DMotionData operand1, Unity.Animation.BlendTree1DMotionData operand2);
        public static bool operator <(Unity.Animation.BlendTree1DMotionData operand1, Unity.Animation.BlendTree1DMotionData operand2);
        public static bool operator <=(Unity.Animation.BlendTree1DMotionData operand1, Unity.Animation.BlendTree1DMotionData operand2);
    }

    public struct BlendTree1DResource : Unity.Entities.IBufferElementData
    {
        public int MotionCount;
        public int MotionStartIndex;
    }

    public struct BlendTree2DMotionData : Unity.Entities.IBufferElementData
    {
        public Unity.Animation.Motion Motion;
        public Unity.Mathematics.float2 MotionPosition;
        public float MotionSpeed;
    }

    public struct BlendTree2DResource : Unity.Entities.IBufferElementData
    {
        public int MotionCount;
        public int MotionStartIndex;
    }

    public struct BlendTree2DSimpleDirectional
    {
        public Unity.Animation.StringHash BlendParameterX;
        public Unity.Animation.StringHash BlendParameterY;
        public Unity.Entities.BlobArray<Unity.Mathematics.float2> MotionPositions;
        public Unity.Entities.BlobArray<Unity.Animation.Motion> Motions;
        public Unity.Entities.BlobArray<float> MotionSpeeds;
    }

    public enum BlendTree2DType
    {
        public const Unity.Animation.BlendTree2DType FreeformCartesian2D = 2;
        public const Unity.Animation.BlendTree2DType FreeformDirectionnal2D = 1;
        public const Unity.Animation.BlendTree2DType SimpleDirectionnal2D = 0;
        public int value__;
    }

    public static class BlendTreeBuilder
    {
        public static Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree1D> CreateBlendTree(Unity.Animation.BlendTree1DMotionData[] motionData);
        public static Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree1D> CreateBlendTree1DFromComponents(Unity.Animation.BlendTree1DResource blendTreeComponent, Unity.Entities.EntityManager entityManager, Unity.Entities.Entity entity);
        public static Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree2DSimpleDirectional> CreateBlendTree2DFromComponents(Unity.Animation.BlendTree2DResource blendTreeComponent, Unity.Entities.EntityManager entityManager, Unity.Entities.Entity entity);
        public static Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree2DSimpleDirectional> CreateBlendTree2DSimpleDirectional(Unity.Animation.BlendTree2DMotionData[] motionData);
    }

    public static class BoneRendererEntityBuilder
    {
        public static void CreateBoneRendererEntities(Unity.Entities.Entity rigEntity, Unity.Entities.EntityManager entityManager, Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rigDefinition, ref Unity.Animation.BoneRendererProperties properties, Unity.Collections.NativeList<int> transformIndices);
        public static void CreateBoneRendererEntities(Unity.Entities.Entity rigEntity, Unity.Entities.EntityManager entityManager, Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rigDefinition, ref Unity.Animation.BoneRendererProperties properties, Unity.Collections.NativeList<Unity.Animation.StringHash> transformIds = default(Unity.Collections.NativeList<Unity.Animation.StringHash>));
        public static void SetupBoneRendererEntities(Unity.Entities.Entity rigEntity, Unity.Entities.Entity boneDataEntity, Unity.Entities.Entity boneRenderEntity, Unity.Entities.EntityManager entityManager, Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rigDefinition, ref Unity.Animation.BoneRendererProperties properties, Unity.Collections.NativeList<int> transformIndices);
    }

    public abstract class BoneRendererMatrixSystemBase : Unity.Entities.SystemBase
    {
        protected BoneRendererMatrixSystemBase() {}
        public static Unity.Entities.EntityQuery <>GetEntityQuery_ForOnUpdate_LambdaJob0_From(Unity.Entities.ComponentSystemBase componentSystem);
        protected virtual void OnCreateForCompiler();
        protected virtual void OnUpdate();
    }

    public struct BoneRendererProperties
    {
        public Unity.Animation.BoneRendererUtils.BoneShape BoneShape;
        public Unity.Mathematics.float4 Color;
        public float Size;
        public static Unity.Animation.BoneRendererProperties Default { get; }
    }

    public abstract class BoneRendererRenderingSystemBase : Unity.Entities.SystemBase
    {
        protected BoneRendererRenderingSystemBase() {}
        protected virtual void OnCreate();
        protected virtual void OnCreateForCompiler();
        protected virtual void OnUpdate();
    }

    public static class BoneRendererUtils
    {
        public static Unity.Mathematics.float4x4 ComputeBoneMatrix(Unity.Mathematics.float3 start, Unity.Mathematics.float3 end, float size = 1);
        public static UnityEngine.Material GetBoneFaceMaterial();
        public static UnityEngine.Mesh GetBoneMesh(Unity.Animation.BoneRendererUtils.BoneShape shape);
        public static UnityEngine.Material GetBoneWireMaterial();
        public enum BoneShape
        {
            public const Unity.Animation.BoneRendererUtils.BoneShape Box = 2;
            public const Unity.Animation.BoneRendererUtils.BoneShape Line = 0;
            public const Unity.Animation.BoneRendererUtils.BoneShape Pyramid = 1;
            public int value__;
        }
        public enum SubMeshType
        {
            public const Unity.Animation.BoneRendererUtils.SubMeshType BoneFaces = 0;
            public const Unity.Animation.BoneRendererUtils.SubMeshType BoneWires = 1;
            public const Unity.Animation.BoneRendererUtils.SubMeshType Count = 2;
            public int value__;
        }
    }

    public struct ChannelMap
    {
        public Unity.Animation.StringHash DestinationId;
        public int OffsetIndex;
        public Unity.Animation.StringHash SourceId;
    }

    public struct ChannelWeightMap
    {
        public Unity.Animation.StringHash Id;
        public float Weight;
    }

    public class ChannelWeightQuery
    {
        public Unity.Animation.ChannelWeightMap[] Channels;
        public ChannelWeightQuery() {}
        public Unity.Entities.BlobAssetReference<Unity.Animation.ChannelWeightTable> ToChannelWeightTable(Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rigDef);
    }

    public struct ChannelWeightTable
    {
        public Unity.Entities.BlobArray<Unity.Animation.WeightEntry> Weights;
    }

    public struct Clip
    {
        public Unity.Animation.BindingSet Bindings;
        public float Duration;
        public float SampleRate;
        public Unity.Entities.BlobArray<float> Samples;
        public Unity.Entities.BlobArray<Unity.Animation.SynchronizationTag> SynchronizationTags;
        public int FrameCount { get; }
        public float LastFrameError { get; }
        public virtual int GetHashCode();
    }

    [System.Runtime.CompilerServices.Extension] public static class ClipExt
    {
        [System.Runtime.CompilerServices.Extension] public static Unity.Animation.BindingSet CreateBindingSet(ref Unity.Animation.Clip _, int translationCount, int rotationCount, int scaleCount, int floatCount, int intCount);
    }

    public struct ClipInstance
    {
        public Unity.Animation.Clip Clip;
        public int ClipHashCode;
        public Unity.Entities.BlobArray<int> FloatBindingMap;
        public Unity.Entities.BlobArray<int> IntBindingMap;
        public int RigHashCode;
        public Unity.Entities.BlobArray<int> RotationBindingMap;
        public Unity.Entities.BlobArray<int> ScaleBindingMap;
        public Unity.Entities.BlobArray<int> TranslationBindingMap;
        [System.Obsolete(@"ClipInstance.Create has been deprecated. Use ClipInstanceBuilder.Create instead. (RemovedAfter 2020-07-15)")] public static Unity.Entities.BlobAssetReference<Unity.Animation.ClipInstance> Create(Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rigDefinition, Unity.Entities.BlobAssetReference<Unity.Animation.Clip> sourceClip);
    }

    public static class ClipInstanceBuilder
    {
        public static Unity.Entities.BlobAssetReference<Unity.Animation.ClipInstance> Create(Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rigDefinition, Unity.Entities.BlobAssetReference<Unity.Animation.Clip> sourceClip);
    }

    public sealed class ClipManager
    {
        public static Unity.Animation.ClipManager Instance { get; }
        public void Clear();
        public Unity.Entities.BlobAssetReference<Unity.Animation.ClipInstance> GetClipFor(Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rigDefinition, Unity.Entities.BlobAssetReference<Unity.Animation.Clip> clip);
    }

    [System.Runtime.CompilerServices.Extension] public static class ClipTransformations
    {
        [System.Runtime.CompilerServices.Extension] public static Unity.Entities.BlobAssetReference<T> Clone<T>(Unity.Entities.BlobAssetReference<T> source) where T : System.ValueType, new();
        public static Unity.Entities.BlobAssetReference<Unity.Animation.Clip> CreatePose(Unity.Entities.BlobAssetReference<Unity.Animation.Clip> source, int frame = 0);
        public static Unity.Entities.BlobAssetReference<Unity.Animation.Clip> FilterBindings(Unity.Entities.BlobAssetReference<Unity.Animation.Clip> source, ref Unity.Animation.BindingSet filter);
        public static Unity.Entities.BlobAssetReference<Unity.Animation.Clip> Reverse(Unity.Entities.BlobAssetReference<Unity.Animation.Clip> source);
    }

    public abstract class ComputeDeformationDataSystemBase : Unity.Entities.SystemBase
    {
        protected ComputeDeformationDataSystemBase() {}
        protected virtual void OnCreate();
        protected virtual void OnCreateForCompiler();
        protected virtual void OnUpdate();
    }

    [System.Obsolete(@"ComputeSkinMatrixSystemBase is deprecated use ComputeDeformationDataSystemBase instead. (RemovedAfter 2020-08-19). ComputeDeformationDataSystemBase (UnityUpgradable)", false)] public abstract class ComputeSkinMatrixSystemBase : Unity.Entities.SystemBase
    {
        protected ComputeSkinMatrixSystemBase() {}
        protected virtual void OnCreateForCompiler();
        protected virtual void OnUpdate();
    }

    public static class Core
    {
        public static void AddPose(ref Unity.Animation.AnimationStream output, ref Unity.Animation.AnimationStream inputA, ref Unity.Animation.AnimationStream inputB);
        public static void Blend(ref Unity.Animation.AnimationStream output, ref Unity.Animation.AnimationStream input1, ref Unity.Animation.AnimationStream input2, float weight);
        public static void Blend(ref Unity.Animation.AnimationStream output, ref Unity.Animation.AnimationStream input1, ref Unity.Animation.AnimationStream input2, float weight, Unity.Collections.NativeArray<Unity.Animation.WeightData> weightMasks);
        public static void BlendAdditiveLayer(ref Unity.Animation.AnimationStream output, ref Unity.Animation.AnimationStream input, float weight);
        public static void BlendAdditiveLayer(ref Unity.Animation.AnimationStream output, ref Unity.Animation.AnimationStream input, float weight, Unity.Collections.NativeArray<Unity.Animation.WeightData> weightMasks);
        public static void BlendOverrideLayer(ref Unity.Animation.AnimationStream output, ref Unity.Animation.AnimationStream input, float weight);
        public static void BlendOverrideLayer(ref Unity.Animation.AnimationStream output, ref Unity.Animation.AnimationStream input, float weight, Unity.Collections.NativeArray<Unity.Animation.WeightData> weightMasks);
        public static float ComputeBlendTree1DDuration(Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree1D> blendTree, ref Unity.Collections.NativeArray<float> weights);
        public static void ComputeBlendTree1DWeights(Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree1D> blendTree, float blendParameter, ref Unity.Collections.NativeArray<float> outWeights);
        public static float ComputeBlendTree2DSimpleDirectionalDuration(Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree2DSimpleDirectional> blendTree, ref Unity.Collections.NativeArray<float> weights);
        public static void ComputeBlendTree2DSimpleDirectionalWeights(Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree2DSimpleDirectional> blendTree, Unity.Mathematics.float2 blendParameter, ref Unity.Collections.NativeArray<float> outWeights);
        public static void ComputeLocalToParentAngularVelocities(ref Unity.Animation.AnimationStream input, ref Unity.Animation.AnimationStream previousInput, float deltaTime, Unity.Collections.NativeArray<Unity.Mathematics.float3> outAngularVelocities);
        public static void ComputeLocalToParentLinearVelocities(ref Unity.Animation.AnimationStream input, ref Unity.Animation.AnimationStream previousInput, float deltaTime, Unity.Collections.NativeArray<Unity.Mathematics.float3> outVelocities);
        public static void ComputeLocalToRoot(ref Unity.Animation.AnimationStream stream, Unity.Collections.NativeArray<Unity.Mathematics.float4x4> outLocalToRoots);
        public static void ComputeLocalToWorld(Unity.Mathematics.float4x4 localToWorld, ref Unity.Animation.AnimationStream stream, Unity.Collections.NativeArray<Unity.Mathematics.float4x4> outLocalToWorlds);
        public static void ComputeLocalToWorldAndRoot(Unity.Mathematics.float4x4 localToWorld, ref Unity.Animation.AnimationStream stream, Unity.Collections.NativeArray<Unity.Mathematics.float4x4> outLocalToWorlds, Unity.Collections.NativeArray<Unity.Mathematics.float4x4> outLocalToRoots);
        public static void ComputeLocalToWorldAngularVelocities(Unity.Mathematics.float4x4 localToWorld, Unity.Mathematics.float4x4 previousLocalToWorld, ref Unity.Animation.AnimationStream input, ref Unity.Animation.AnimationStream previousInput, float deltaTime, Unity.Collections.NativeArray<Unity.Mathematics.float3> outAngularVelocities);
        public static void ComputeLocalToWorldLinearVelocities(Unity.Mathematics.float4x4 localToWorld, Unity.Mathematics.float4x4 previousLocalToWorld, ref Unity.Animation.AnimationStream input, ref Unity.Animation.AnimationStream previousInput, float deltaTime, Unity.Collections.NativeArray<Unity.Mathematics.float3> outVelocities);
        public static void ComputeWeightDataFromChannelIndices(Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rig, float defaultWeight, Unity.Collections.NativeArray<int> channelIndices, Unity.Collections.NativeArray<float> channelWeights, Unity.Collections.NativeArray<Unity.Animation.WeightData> weightData);
        public static void EvaluateClip(Unity.Entities.BlobAssetReference<Unity.Animation.ClipInstance> clipInstance, float time, ref Unity.Animation.AnimationStream stream, int additive);
        public static int FindBindingIndex(ref Unity.Entities.BlobArray<Unity.Animation.StringHash> bindings, Unity.Animation.StringHash searchedBinding);
        public static void InversePose(ref Unity.Animation.AnimationStream output, ref Unity.Animation.AnimationStream input);
        public static float MixerAdd(ref Unity.Animation.AnimationStream output, ref Unity.Animation.AnimationStream add, float weight, float sumWeight);
        public static void MixerBegin(ref Unity.Animation.AnimationStream output);
        public static void MixerEnd(ref Unity.Animation.AnimationStream output, ref Unity.Animation.AnimationStream defaultPoseInput, float sumWeight);
        public static void RigRemapper(Unity.Entities.BlobAssetReference<Unity.Animation.RigRemapTable> remapTable, ref Unity.Animation.AnimationStream destinationStream, ref Unity.Animation.AnimationStream sourceStream);
        public static void SetWeightValueFromChannelIndex(Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rig, float weight, int channelIndex, Unity.Collections.NativeArray<Unity.Animation.WeightData> weightData);
        public static void SolveAimConstraint(ref Unity.Animation.AnimationStream stream, ref Unity.Animation.Core.AimConstraintData data, float weight);
        public static void SolveParentConstraint(ref Unity.Animation.AnimationStream stream, ref Unity.Animation.Core.ParentConstraintData data, float weight);
        public static void SolvePositionConstraint(ref Unity.Animation.AnimationStream stream, ref Unity.Animation.Core.PositionConstraintData data, float weight);
        public static void SolveRotationConstraint(ref Unity.Animation.AnimationStream stream, ref Unity.Animation.Core.RotationConstraintData data, float weight);
        public static void SolveTwistCorrection(ref Unity.Animation.AnimationStream stream, ref Unity.Animation.Core.TwistCorrectionData data, float weight);
        public static void SolveTwoBoneIK(ref Unity.Animation.AnimationStream stream, ref Unity.Animation.Core.TwoBoneIKData data, float weight);
        public static int WeightDataSize(Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rig);
        public static void WeightPose(ref Unity.Animation.AnimationStream output, ref Unity.Animation.AnimationStream input, Unity.Collections.NativeArray<Unity.Animation.WeightData> weights);
        public struct AimConstraintData
        {
            public int Index;
            public Unity.Mathematics.float3 LocalAimAxis;
            public Unity.Mathematics.bool3 LocalAxesMask;
            public Unity.Mathematics.quaternion LocalOffset;
            public float MaxAngleLimit;
            public float MinAngleLimit;
            public Unity.Collections.NativeArray<Unity.Mathematics.quaternion> SourceOffsets;
            public Unity.Collections.NativeArray<Unity.Mathematics.float3> SourcePositions;
            public Unity.Collections.NativeArray<float> SourceWeights;
            public static Unity.Animation.Core.AimConstraintData Default();
        }
        public struct ClipKeyframe
        {
            public int Left;
            public int Right;
            public float Weight;
            public static Unity.Animation.Core.ClipKeyframe Create(ref Unity.Animation.Clip clip, float time);
        }
        public struct ParentConstraintData
        {
            public int Index;
            public Unity.Mathematics.bool3 LocalRotationAxesMask;
            public Unity.Mathematics.bool3 LocalTranslationAxesMask;
            public Unity.Collections.NativeArray<Unity.Mathematics.RigidTransform> SourceOffsets;
            public Unity.Collections.NativeArray<Unity.Mathematics.RigidTransform> SourceTx;
            public Unity.Collections.NativeArray<float> SourceWeights;
            public static Unity.Animation.Core.ParentConstraintData Default();
        }
        public struct PositionConstraintData
        {
            public int Index;
            public Unity.Mathematics.bool3 LocalAxesMask;
            public Unity.Mathematics.float3 LocalOffset;
            public Unity.Collections.NativeArray<Unity.Mathematics.float3> SourceOffsets;
            public Unity.Collections.NativeArray<Unity.Mathematics.float3> SourcePositions;
            public Unity.Collections.NativeArray<float> SourceWeights;
            public static Unity.Animation.Core.PositionConstraintData Default();
        }
        public struct RotationConstraintData
        {
            public int Index;
            public Unity.Mathematics.bool3 LocalAxesMask;
            public Unity.Mathematics.quaternion LocalOffset;
            public Unity.Collections.NativeArray<Unity.Mathematics.quaternion> SourceOffsets;
            public Unity.Collections.NativeArray<Unity.Mathematics.quaternion> SourceRotations;
            public Unity.Collections.NativeArray<float> SourceWeights;
            public static Unity.Animation.Core.RotationConstraintData Default();
        }
        public struct TwistCorrectionData
        {
            public Unity.Mathematics.float3 LocalTwistAxis;
            public Unity.Mathematics.quaternion SourceInverseDefaultRotation;
            public Unity.Mathematics.quaternion SourceRotation;
            public Unity.Collections.NativeArray<int> TwistIndices;
            public Unity.Collections.NativeArray<float> TwistWeights;
            public static Unity.Animation.Core.TwistCorrectionData Default();
        }
        public struct TwoBoneIKData
        {
            public Unity.Mathematics.float3 Hint;
            public float HintWeight;
            public int MidIndex;
            public int RootIndex;
            public Unity.Mathematics.RigidTransform Target;
            public Unity.Mathematics.RigidTransform TargetOffset;
            public float TargetPositionWeight;
            public float TargetRotationWeight;
            public int TipIndex;
            public static Unity.Animation.Core.TwoBoneIKData Default();
        }
    }

    public static class Debug
    {
        public static void Log(string message);
        public static void LogError(string message);
        public static void LogWarning(string message);
    }

    public struct DisableRootTransformReadWriteTag : Unity.Entities.IComponentData
    {
    }

    public struct FloatChannel : System.IEquatable<Unity.Animation.FloatChannel>, Unity.Animation.IAnimationChannel, Unity.Animation.IAnimationChannel<float>
    {
        public virtual float DefaultValue { get; set; }
        public virtual Unity.Animation.StringHash Id { get; set; }
        public virtual bool Equals(Unity.Animation.FloatChannel other);
    }

    public interface IAnimatedRootMotion : Unity.Entities.IComponentData
    {
        public abstract Unity.Mathematics.RigidTransform Delta { get; set; }
    }

    public interface IAnimationChannel
    {
        public abstract Unity.Animation.StringHash Id { get; set; }
    }

    public interface IAnimationChannel<T> : Unity.Animation.IAnimationChannel where T : System.ValueType, new()
    {
        public abstract T DefaultValue { get; set; }
    }

    public interface IAnimationSystemTag : Unity.Entities.IComponentData
    {
    }

    public struct IntChannel : System.IEquatable<Unity.Animation.IntChannel>, Unity.Animation.IAnimationChannel, Unity.Animation.IAnimationChannel<int>
    {
        public virtual int DefaultValue { get; set; }
        public virtual Unity.Animation.StringHash Id { get; set; }
        public virtual bool Equals(Unity.Animation.IntChannel other);
    }

    public interface IReadTransformHandle : Unity.Animation.ITransformHandle, Unity.Entities.IBufferElementData
    {
    }

    public interface ITransformHandle : Unity.Entities.IBufferElementData
    {
        public abstract Unity.Entities.Entity Entity { get; set; }
        public abstract int Index { get; set; }
    }

    public interface IWriteTransformHandle : Unity.Animation.ITransformHandle, Unity.Entities.IBufferElementData
    {
    }

    public struct LocalRotationChannel : System.IEquatable<Unity.Animation.LocalRotationChannel>, Unity.Animation.IAnimationChannel, Unity.Animation.IAnimationChannel<Unity.Mathematics.quaternion>
    {
        public virtual Unity.Mathematics.quaternion DefaultValue { get; set; }
        public virtual Unity.Animation.StringHash Id { get; set; }
        public virtual bool Equals(Unity.Animation.LocalRotationChannel other);
    }

    public struct LocalScaleChannel : System.IEquatable<Unity.Animation.LocalScaleChannel>, Unity.Animation.IAnimationChannel, Unity.Animation.IAnimationChannel<Unity.Mathematics.float3>
    {
        public virtual Unity.Mathematics.float3 DefaultValue { get; set; }
        public virtual Unity.Animation.StringHash Id { get; set; }
        public virtual bool Equals(Unity.Animation.LocalScaleChannel other);
    }

    public struct LocalTranslationChannel : System.IEquatable<Unity.Animation.LocalTranslationChannel>, Unity.Animation.IAnimationChannel, Unity.Animation.IAnimationChannel<Unity.Mathematics.float3>
    {
        public virtual Unity.Mathematics.float3 DefaultValue { get; set; }
        public virtual Unity.Animation.StringHash Id { get; set; }
        public virtual bool Equals(Unity.Animation.LocalTranslationChannel other);
    }

    public static class mathex
    {
        public static Unity.Animation.quaternion4 add(Unity.Animation.quaternion4 q1, Unity.Animation.quaternion4 q2);
        public static Unity.Mathematics.quaternion add(Unity.Mathematics.quaternion p, Unity.Mathematics.quaternion q);
        public static Unity.Animation.AffineTransform AffineTransform(Unity.Mathematics.float3x4 m);
        public static Unity.Animation.AffineTransform AffineTransform(Unity.Mathematics.float4x4 m);
        public static Unity.Animation.AffineTransform AffineTransform(Unity.Mathematics.float3 translation, Unity.Mathematics.float3x3 rs);
        public static Unity.Animation.AffineTransform AffineTransform(Unity.Mathematics.float3 translation, Unity.Mathematics.quaternion rotation);
        public static Unity.Animation.AffineTransform AffineTransform(Unity.Mathematics.float3 translation, Unity.Mathematics.quaternion rotation, Unity.Mathematics.float3 scale);
        public static float angle(Unity.Mathematics.float3 from, Unity.Mathematics.float3 to);
        public static Unity.Mathematics.float3 chgsign(Unity.Mathematics.float3 val, Unity.Mathematics.float3 sign);
        public static Unity.Mathematics.float4 chgsign(Unity.Mathematics.float4 val, Unity.Mathematics.float4 sign);
        public static Unity.Animation.quaternion4 conjugate(Unity.Animation.quaternion4 q);
        public static Unity.Mathematics.float4 cross(Unity.Mathematics.float4 p0, Unity.Mathematics.float4 p1);
        public static Unity.Mathematics.float4 dot(Unity.Animation.quaternion4 q1, Unity.Animation.quaternion4 q2);
        public static Unity.Mathematics.float3x4 float3x4(Unity.Animation.AffineTransform transform);
        public static Unity.Mathematics.float4x4 float4x4(Unity.Animation.AffineTransform transform);
        public static Unity.Mathematics.float4x4 float4x4(Unity.Animation.quaternion4 q);
        public static Unity.Mathematics.quaternion fromTo(Unity.Mathematics.float3 a, Unity.Mathematics.float3 b);
        public static System.UInt32 hash(Unity.Animation.AffineTransform a);
        public static System.UInt32 hash(Unity.Animation.quaternion4 q);
        public static Unity.Mathematics.uint4 hashwide(Unity.Animation.AffineTransform a);
        public static Unity.Mathematics.uint4 hashwide(Unity.Animation.quaternion4 q);
        public static Unity.Animation.AffineTransform inverse(Unity.Animation.AffineTransform a);
        public static Unity.Mathematics.float3x3 inverse(Unity.Mathematics.float3x3 m);
        public static Unity.Animation.quaternion4 lerp(Unity.Animation.quaternion4 q1, Unity.Animation.quaternion4 q2, Unity.Mathematics.float4 blend);
        public static Unity.Mathematics.quaternion lerp(Unity.Mathematics.quaternion p, Unity.Mathematics.quaternion q, float blend);
        public static Unity.Animation.AffineTransform mul(Unity.Animation.AffineTransform a, Unity.Animation.AffineTransform b);
        public static Unity.Animation.AffineTransform mul(Unity.Animation.AffineTransform a, Unity.Mathematics.float3x3 rs);
        public static Unity.Animation.AffineTransform mul(Unity.Mathematics.float3x3 rs, Unity.Animation.AffineTransform b);
        public static Unity.Animation.quaternion4 mul(Unity.Animation.quaternion4 lhs, Unity.Animation.quaternion4 rhs);
        public static Unity.Mathematics.float3 mul(Unity.Animation.AffineTransform a, Unity.Mathematics.float3 v);
        public static Unity.Mathematics.quaternion mul(Unity.Mathematics.quaternion q1, Unity.Mathematics.quaternion q2);
        public static Unity.Mathematics.float3x3 mulScale(Unity.Mathematics.float3x3 m, Unity.Mathematics.float3 s);
        public static Unity.Animation.quaternion4 normalize(Unity.Animation.quaternion4 q);
        public static Unity.Animation.quaternion4 normalizesafe(Unity.Animation.quaternion4 q);
        public static Unity.Mathematics.float3 one();
        public static Unity.Mathematics.float3 projectOnPlane(Unity.Mathematics.float3 vector, Unity.Mathematics.float3 planeNormal);
        public static Unity.Animation.quaternion4 quaternion4(Unity.Mathematics.float4x4 m);
        public static Unity.Animation.quaternion4 quaternion4(Unity.Mathematics.float4 x, Unity.Mathematics.float4 y, Unity.Mathematics.float4 z, Unity.Mathematics.float4 w);
        public static Unity.Animation.quaternion4 quaternion4(Unity.Mathematics.quaternion q1, Unity.Mathematics.quaternion q2, Unity.Mathematics.quaternion q3, Unity.Mathematics.quaternion q4);
        public static Unity.Animation.quaternion4 quatWeight(Unity.Animation.quaternion4 q, Unity.Mathematics.float4 weight);
        public static Unity.Mathematics.quaternion quatWeight(Unity.Mathematics.quaternion q, float weight);
        public static Unity.Mathematics.float3 rcpsafe(Unity.Mathematics.float3 x);
        public static Unity.Mathematics.float3 right();
        public static Unity.Mathematics.RigidTransform rigidPow(Unity.Mathematics.RigidTransform x, System.UInt32 pow);
        public static Unity.Mathematics.float3x3 scaleMul(Unity.Mathematics.float3 s, Unity.Mathematics.float3x3 m);
        public static Unity.Mathematics.quaternion scaleMulQuat(Unity.Mathematics.float3 scale, Unity.Mathematics.quaternion q);
        public static Unity.Animation.quaternion4 select(Unity.Animation.quaternion4 a, Unity.Animation.quaternion4 b, Unity.Mathematics.bool4 c);
        public static Unity.Mathematics.quaternion select(Unity.Mathematics.quaternion a, Unity.Mathematics.quaternion b, bool c);
        public static Unity.Mathematics.RigidTransform select(Unity.Mathematics.RigidTransform a, Unity.Mathematics.RigidTransform b, bool c);
        public static Unity.Mathematics.float3 toEuler(Unity.Mathematics.quaternion q, Unity.Mathematics.math.RotationOrder order = 4);
        public static Unity.Mathematics.float4x4 transpose(Unity.Mathematics.float4x4 m);
    }

    public struct Motion
    {
        public Unity.Entities.BlobAssetReference<Unity.Animation.Clip> Clip;
    }

    public struct NotSupportedRootMotion : Unity.Animation.IAnimatedRootMotion, Unity.Entities.IComponentData
    {
        public virtual Unity.Mathematics.RigidTransform Delta { get; set; }
    }

    public struct NotSupportedTransformHandle : Unity.Animation.IReadTransformHandle, Unity.Animation.ITransformHandle, Unity.Animation.IWriteTransformHandle, Unity.Entities.IBufferElementData
    {
        public virtual Unity.Entities.Entity Entity { get; set; }
        public virtual int Index { get; set; }
    }

    public struct quaternion4 : System.IEquatable<Unity.Animation.quaternion4>, System.IFormattable
    {
        public static readonly Unity.Animation.quaternion4 identity;
        public Unity.Mathematics.float4 w;
        public Unity.Mathematics.float4 x;
        public Unity.Mathematics.float4 y;
        public Unity.Mathematics.float4 z;
        public quaternion4(Unity.Mathematics.float4x4 m) {}
        public quaternion4(Unity.Mathematics.float4 x, Unity.Mathematics.float4 y, Unity.Mathematics.float4 z, Unity.Mathematics.float4 w) {}
        public quaternion4(Unity.Mathematics.quaternion q0, Unity.Mathematics.quaternion q1, Unity.Mathematics.quaternion q2, Unity.Mathematics.quaternion q3) {}
        public virtual bool Equals(object o);
        public virtual bool Equals(Unity.Animation.quaternion4 q);
        public virtual int GetHashCode();
        public static Unity.Animation.quaternion4 operator +(Unity.Animation.quaternion4 lhs, Unity.Animation.quaternion4 rhs);
        public static Unity.Animation.quaternion4 operator *(Unity.Animation.quaternion4 lhs, float rhs);
        public static Unity.Animation.quaternion4 operator *(Unity.Animation.quaternion4 lhs, Unity.Mathematics.float4 rhs);
        public virtual string ToString();
        public virtual string ToString(string format, System.IFormatProvider formatProvider);
    }

    public struct Rig : Unity.Entities.IComponentData
    {
        public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> Value;
        public static Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> op_Implicit(Unity.Animation.Rig rig);
    }

    public static class RigBuilder
    {
        public static Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> CreateRigDefinition(Unity.Animation.IAnimationChannel[] animationChannels);
        public static Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> CreateRigDefinition(Unity.Animation.SkeletonNode[] skeletonNodes, Unity.Animation.Axis[] axis = default(Unity.Animation.Axis[]));
        public static Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> CreateRigDefinition(Unity.Animation.SkeletonNode[] skeletonNodes, Unity.Animation.Axis[] axes, Unity.Animation.IAnimationChannel[] animationChannels);
    }

    public static class RigBuilderUtility
    {
        public static Unity.Animation.IAnimationChannel[] ExtractAnimationChannelsFromClips(Unity.Entities.BlobAssetReference<Unity.Animation.Clip>[] clips);
    }

    public abstract class RigComputeMatricesSystemBase : Unity.Entities.SystemBase
    {
        protected RigComputeMatricesSystemBase() {}
        protected virtual void OnCreate();
        protected virtual void OnCreateForCompiler();
        protected virtual void OnUpdate();
    }

    public struct RigDefinition : System.IEquatable<Unity.Animation.RigDefinition>
    {
        public Unity.Animation.BindingSet Bindings;
        public Unity.Entities.BlobArray<float> DefaultValues;
        public Unity.Animation.Skeleton Skeleton;
        public virtual bool Equals(object other);
        public virtual bool Equals(Unity.Animation.RigDefinition other);
        public virtual int GetHashCode();
        public static bool operator ==(Unity.Animation.RigDefinition lhs, Unity.Animation.RigDefinition rhs);
        public static bool operator !=(Unity.Animation.RigDefinition lhs, Unity.Animation.RigDefinition rhs);
    }

    [System.Runtime.CompilerServices.Extension] public static class RigDefinitionExt
    {
        [System.Runtime.CompilerServices.Extension] public static Unity.Animation.BindingSet CreateBindingSet(ref Unity.Animation.RigDefinition _, int translationCount, int rotationCount, int scaleCount, int floatCount, int intCount);
    }

    public struct RigEntity : Unity.Entities.IComponentData
    {
        public Unity.Entities.Entity Value;
    }

    public static class RigEntityBuilder
    {
        public static readonly Unity.Entities.ComponentType[] RigComponentTypes;
        public static readonly Unity.Entities.ComponentType[] RigPrefabComponentTypes;
        public static void AddReadTransformHandle<T>(Unity.Entities.EntityManager entityManager, Unity.Entities.Entity rig, Unity.Entities.Entity transform, int index) where T : System.ValueType, Unity.Animation.IReadTransformHandle, new();
        public static void AddWriteTransformHandle<T>(Unity.Entities.EntityManager entityManager, Unity.Entities.Entity rig, Unity.Entities.Entity transform, int index) where T : System.ValueType, Unity.Animation.IWriteTransformHandle, new();
        public static Unity.Entities.Entity CreatePrefabEntity(Unity.Entities.EntityManager entityManager, Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rigDefinition);
        public static void SetupRigEntity(Unity.Entities.Entity entity, Unity.Entities.EntityManager entityManager, Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rigDefinition);
        public struct RigBuffers
        {
            public Unity.Entities.DynamicBuffer<Unity.Animation.AnimatedData> Data;
            public Unity.Entities.DynamicBuffer<Unity.Animation.AnimatedLocalToWorld> GlobalMatrices;
            public RigBuffers(Unity.Entities.EntityManager entityManager, Unity.Entities.Entity entity) {}
            public void InitializeBuffers(Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rigDefinition);
            public void ResizeBuffers(Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rigDefinition);
        }
    }

    public struct RigRemapEntry
    {
        public int DestinationIndex;
        public int OffsetIndex;
        public int SourceIndex;
    }

    public class RigRemapQuery
    {
        public Unity.Animation.ChannelMap[] AllChannels;
        public Unity.Animation.ChannelMap[] FloatChannels;
        public Unity.Animation.ChannelMap[] IntChannels;
        public Unity.Animation.ChannelMap[] RotationChannels;
        public Unity.Animation.RigRotationOffset[] RotationOffsets;
        public Unity.Animation.ChannelMap[] ScaleChannels;
        public Unity.Animation.ChannelMap[] TranslationChannels;
        public Unity.Animation.RigTranslationOffset[] TranslationOffsets;
        public RigRemapQuery() {}
        public Unity.Entities.BlobAssetReference<Unity.Animation.RigRemapTable> ToRigRemapTable(Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> sourceRigDefinition, Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> destinationRigDefinition);
    }

    public enum RigRemapSpace
    {
        public const Unity.Animation.RigRemapSpace LocalToParent = 0;
        public const Unity.Animation.RigRemapSpace LocalToRoot = 1;
        public byte value__;
    }

    public struct RigRemapTable
    {
        public Unity.Entities.BlobArray<Unity.Animation.RigRemapEntry> FloatMappings;
        public Unity.Entities.BlobArray<Unity.Animation.RigRemapEntry> IntMappings;
        public Unity.Mathematics.int2 LocalToParentTRCount;
        public Unity.Entities.BlobArray<Unity.Animation.RigRemapEntry> RotationMappings;
        public Unity.Entities.BlobArray<Unity.Animation.RigRotationOffset> RotationOffsets;
        public Unity.Entities.BlobArray<Unity.Animation.RigRemapEntry> ScaleMappings;
        public Unity.Entities.BlobArray<Unity.Mathematics.int2> SortedLocalToRootTREntries;
        public Unity.Entities.BlobArray<Unity.Animation.RigRemapEntry> TranslationMappings;
        public Unity.Entities.BlobArray<Unity.Animation.RigTranslationOffset> TranslationOffsets;
    }

    public static class RigRemapUtils
    {
        public static Unity.Entities.BlobAssetReference<Unity.Animation.RigRemapTable> CreateRemapTable(Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> srcRig, Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> dstRig, Unity.Animation.RigRemapUtils.ChannelFilter filter = 31, Unity.Animation.RigRemapUtils.OffsetOverrides offsetOverrides = default(Unity.Animation.RigRemapUtils.OffsetOverrides));
        [System.Flags] public enum ChannelFilter
        {
            public const Unity.Animation.RigRemapUtils.ChannelFilter All = 31;
            public const Unity.Animation.RigRemapUtils.ChannelFilter Float = 8;
            public const Unity.Animation.RigRemapUtils.ChannelFilter Int = 16;
            public const Unity.Animation.RigRemapUtils.ChannelFilter None = 0;
            public const Unity.Animation.RigRemapUtils.ChannelFilter Rotation = 2;
            public const Unity.Animation.RigRemapUtils.ChannelFilter Scale = 4;
            public const Unity.Animation.RigRemapUtils.ChannelFilter Translation = 1;
            public byte value__;
        }
        public struct OffsetOverrides : System.IDisposable
        {
            public bool HasRotationOffsetOverrides { get; }
            public bool HasTranslationOffsetOverrides { get; }
            public bool IsCreated { get; }
            public OffsetOverrides(int capacity, Unity.Collections.Allocator allocator) {}
            public void AddRotationOffsetOverride(Unity.Animation.StringHash binding, Unity.Animation.RigRotationOffset offset);
            public void AddTranslationOffsetOverride(Unity.Animation.StringHash binding, Unity.Animation.RigTranslationOffset offset);
            public virtual void Dispose();
        }
    }

    public struct RigRootEntity : Unity.Entities.IComponentData
    {
        public Unity.Entities.Entity Value;
    }

    public struct RigRotationOffset
    {
        public Unity.Mathematics.quaternion PostRotation;
        public Unity.Mathematics.quaternion PreRotation;
        public Unity.Animation.RigRemapSpace Space;
    }

    public struct RigTranslationOffset
    {
        public Unity.Mathematics.quaternion Rotation;
        public float Scale;
        public Unity.Animation.RigRemapSpace Space;
    }

    public static class RigUtils
    {
        public static Unity.Entities.Entity InstantiateDebugRigEntity(Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rigDefinition, Unity.Entities.EntityManager entityManager, ref Unity.Animation.BoneRendererProperties props, Unity.Collections.NativeList<Unity.Animation.StringHash> ids = default(Unity.Collections.NativeList<Unity.Animation.StringHash>));
        public static Unity.Entities.Entity InstantiateDebugRigEntity(Unity.Entities.Entity rigEntity, Unity.Entities.EntityManager entityManager, ref Unity.Animation.BoneRendererProperties props, Unity.Collections.NativeList<Unity.Animation.StringHash> ids = default(Unity.Collections.NativeList<Unity.Animation.StringHash>));
    }

    public struct RootMotionOffset : Unity.Entities.IComponentData
    {
        public Unity.Mathematics.RigidTransform Value;
    }

    public struct SharedRigHash : Unity.Entities.ISharedComponentData
    {
        public int Value;
    }

    public struct Skeleton
    {
        public Unity.Entities.BlobArray<Unity.Animation.Axis> Axis;
        public Unity.Entities.BlobArray<int> AxisIndexes;
        public Unity.Entities.BlobArray<Unity.Animation.StringHash> Ids;
        public Unity.Entities.BlobArray<int> ParentIndexes;
        public int BoneCount { get; }
    }

    public struct SkeletonNode
    {
        public int AxisIndex;
        public Unity.Animation.StringHash Id;
        public Unity.Mathematics.quaternion LocalRotationDefaultValue;
        public Unity.Mathematics.float3 LocalScaleDefaultValue;
        public Unity.Mathematics.float3 LocalTranslationDefaultValue;
        public int ParentIndex;
    }

    [System.Obsolete(@"SkinMatrix is deprecated use Unity.Deformations.SkinMatrix instead. (RemovedAfter 2020-08-19)", false)] public struct SkinMatrix : Unity.Entities.IBufferElementData
    {
        public Unity.Mathematics.float3x4 Value;
    }

    [System.Obsolete(@"SkinnedMeshRigEntity is deprecated use RigEntity instead. (RemovedAfter 2020-08-19). (UnityUpgradable) -> RigEntity", false)] public struct SkinnedMeshRigEntity : Unity.Entities.IComponentData
    {
        public Unity.Entities.Entity Value;
    }

    public struct SkinnedMeshToRigIndexMapping : Unity.Entities.IBufferElementData
    {
        public int RigIndex;
        public int SkinMeshIndex;
    }

    public struct StringHash : System.IEquatable<Unity.Animation.StringHash>
    {
        public System.UInt32 Id;
        public StringHash(string str) {}
        public virtual bool Equals(object other);
        public virtual bool Equals(Unity.Animation.StringHash other);
        public virtual int GetHashCode();
        public static bool IsNullOrEmpty(Unity.Animation.StringHash strHash);
        public static bool operator ==(Unity.Animation.StringHash lhs, Unity.Animation.StringHash rhs);
        public static Unity.Animation.StringHash op_Implicit(string str);
        public static Unity.Animation.StringHash op_Implicit(System.UInt32 id);
        public static bool operator !=(Unity.Animation.StringHash lhs, Unity.Animation.StringHash rhs);
    }

    public struct SynchronizationTag
    {
        public float NormalizedTime;
        public int State;
        public Unity.Animation.StringHash Type;
    }

    public struct WeightData : Unity.Entities.IBufferElementData
    {
        public float Value;
    }

    public struct WeightEntry
    {
        public int Index;
        public float Weight;
    }
}

namespace Unity.Animation.BoneRenderer
{
    public struct BoneColor : Unity.Entities.IComponentData
    {
        public Unity.Mathematics.float4 Value;
    }

    public struct BoneRendererEntity : Unity.Entities.IComponentData
    {
        public Unity.Entities.Entity Value;
    }

    public struct BoneShape : Unity.Entities.ISharedComponentData
    {
        public Unity.Animation.BoneRendererUtils.BoneShape Value;
    }

    public struct BoneSize : Unity.Entities.IComponentData
    {
        public float Value;
    }

    public struct BoneWorldMatrix : Unity.Entities.IBufferElementData
    {
        public Unity.Mathematics.float4x4 Value;
    }

    [System.Obsolete(@"Unity.Animation.BoneRenderer.RigEntity is deprecated use Unity.Animation.RigEntity instead. (RemovedAfter 2020-08-19).", false)] public struct RigEntity : Unity.Entities.IComponentData
    {
        public Unity.Entities.Entity Value;
    }

    public struct RigIndex : Unity.Entities.IBufferElementData
    {
        public int Value;
    }

    public struct RigParentIndex : Unity.Entities.IBufferElementData
    {
        public int Value;
    }
}

namespace Unity.Collections
{
    [System.Runtime.CompilerServices.Extension] public static class NativeArrayUniqueExtension
    {
        [System.Runtime.CompilerServices.Extension] public static int Unique<T>(Unity.Collections.NativeArray<T> array) where T : System.ValueType, System.IComparable<T>, new();
        public static int Unique<[System.Runtime.CompilerServices.IsUnmanaged]T>(T* array, int length) where T : System.ValueType, System.ValueType modreq(System.Runtime.InteropServices.UnmanagedType), System.IComparable<T>, new();
        [System.Runtime.CompilerServices.Extension] public static int Unique<T, U>(Unity.Collections.NativeArray<T> array, U comp) where T : System.ValueType, new() where U : System.Collections.Generic.IComparer<T>;
        public static int Unique<[System.Runtime.CompilerServices.IsUnmanaged]T, U>(T* array, int length, U comp) where T : System.ValueType, System.ValueType modreq(System.Runtime.InteropServices.UnmanagedType), new() where U : System.Collections.Generic.IComparer<T>;
    }
}
