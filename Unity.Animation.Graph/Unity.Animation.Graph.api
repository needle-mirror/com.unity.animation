// This file is generated. Do not modify by hand.
// XML documentation file not found. To check if public methods have XML comments,
// make sure the XML doc file is present and located next to the scraped dll
namespace Unity.Animation
{
    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Adds two animation streams", false)] public class AddPoseNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.AddPoseNode.Data, Unity.Animation.AddPoseNode.SimPorts, Unity.Animation.AddPoseNode.KernelData, Unity.Animation.AddPoseNode.KernelDefs, Unity.Animation.AddPoseNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public AddPoseNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.AddPoseNode.KernelData, Unity.Animation.AddPoseNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.AddPoseNode.KernelData data, ref Unity.Animation.AddPoseNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfileMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream A", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.AddPoseNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> InputA;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream B", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.AddPoseNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> InputB;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.AddPoseNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.AddPoseNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Constraints", @"Aim constraint based on multiple sources", false)] [Unity.DataFlowGraph.Attributes.PortGroupDefinition(@"Source Count", 1, 1, -1, )] public class AimConstraintNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.AimConstraintNode.Data, Unity.Animation.AimConstraintNode.SimPorts, Unity.Animation.AimConstraintNode.KernelData, Unity.Animation.AimConstraintNode.KernelDefs, Unity.Animation.AimConstraintNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.AimConstraintNode.SetupMessage>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public AimConstraintNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.AimConstraintNode.SetupMessage msg);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.AimConstraintNode.KernelData, Unity.Animation.AimConstraintNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext ctx, Unity.Animation.AimConstraintNode.KernelData data, ref Unity.Animation.AimConstraintNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public int Index;
            public Unity.Mathematics.float3 LocalAimAxis;
            public Unity.Mathematics.bool3 LocalAxesMask;
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Constrained animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.AimConstraintNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Extra local offset to apply to the constrained bone expressed in Euler angles (degrees)", false, -1, @"zero", 2, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.AimConstraintNode, Unity.Mathematics.float3> LocalOffset;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Extra local offset rotation order", false, -1, 4, 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.AimConstraintNode, Unity.Mathematics.math.RotationOrder> LocalOffsetRotationOrder;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Maximum angle limit (degrees)", false, -1, 180, 0, false, -180, 180)] public Unity.DataFlowGraph.DataInput<Unity.Animation.AimConstraintNode, float> MaxAngleLimit;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Minimum angle limit (degrees)", false, -1, -180, 0, false, -180, 180)] public Unity.DataFlowGraph.DataInput<Unity.Animation.AimConstraintNode, float> MinAngleLimit;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.AimConstraintNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Source Rotation Offset", @"Rotation offset of source", false, 1, @"identity", 2, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.AimConstraintNode, Unity.Mathematics.quaternion>> SourceOffsets;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Source Position", @"Position of source", false, 1, @"zero", 2, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.AimConstraintNode, Unity.Mathematics.float3>> SourcePositions;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Source Weight", @"Weight of source", false, 1, 1, 0, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.AimConstraintNode, float>> SourceWeights;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Constraint weight", false, -1, 1, 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.AimConstraintNode, float> Weight;
        }
        public struct SetupMessage
        {
            public int Index;
            public Unity.Mathematics.float3 LocalAimAxis;
            public Unity.Mathematics.bool3 LocalAxesMask;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Setup", @"Aim constraint properties", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.AimConstraintNode, Unity.Animation.AimConstraintNode.SetupMessage> ConstraintSetup;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.AimConstraintNode, Unity.Animation.Rig> Rig;
        }
    }

    public abstract class AnimationSystemBase<TTag, TReadTransformHandle, TWriteTransformHandle> : Unity.Entities.SystemBase, Unity.Animation.IAnimationSystem, Unity.Animation.IAnimationSystem<TTag> where TTag : System.ValueType, Unity.Animation.IAnimationSystemTag, new() where TReadTransformHandle : System.ValueType, Unity.Animation.IReadTransformHandle, new() where TWriteTransformHandle : System.ValueType, Unity.Animation.IWriteTransformHandle, new()
    {
        public virtual int RefCount { get; }
        public virtual Unity.DataFlowGraph.NodeSet Set { get; }
        public virtual TTag TagComponent { get; }
        protected AnimationSystemBase() {}
        public virtual void AddRef();
        public virtual Unity.Animation.GraphHandle CreateGraph();
        public virtual Unity.DataFlowGraph.NodeHandle<T> CreateNode<T>(Unity.Animation.GraphHandle handle) where T : Unity.DataFlowGraph.NodeDefinition, new();
        public virtual Unity.DataFlowGraph.NodeHandle<Unity.DataFlowGraph.ComponentNode> CreateNode(Unity.Animation.GraphHandle handle, Unity.Entities.Entity entity);
        public virtual void Dispose(Unity.Animation.GraphHandle handle);
        protected virtual void OnCreate();
        protected virtual void OnCreateForCompiler();
        protected virtual void OnUpdate();
        public virtual void RemoveRef();
        protected Unity.Jobs.JobHandle ScheduleGraphEvaluationJobs(Unity.Jobs.JobHandle inputDeps);
        protected Unity.Jobs.JobHandle ScheduleReadComponentDataJobs(Unity.Jobs.JobHandle inputDeps);
        protected Unity.Jobs.JobHandle ScheduleWriteComponentDataJobs(Unity.Jobs.JobHandle inputDeps);
    }

    public enum BlendingMode
    {
        public const Unity.Animation.BlendingMode Additive = 1;
        public const Unity.Animation.BlendingMode Override = 0;
        public int value__;
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Blend Trees", @"Evaluates a 1D BlendTree based on a blend parameter", false)] public class BlendTree1DNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.BlendTree1DNode.Data, Unity.Animation.BlendTree1DNode.SimPorts, Unity.Animation.BlendTree1DNode.KernelData, Unity.Animation.BlendTree1DNode.KernelDefs, Unity.Animation.BlendTree1DNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.IMsgHandler<Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree1D>>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public BlendTree1DNode() {}
        protected virtual void Destroy(Unity.DataFlowGraph.NodeHandle handle);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree1D> blendTree);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        [Unity.DataFlowGraph.Managed] public struct Data : Unity.DataFlowGraph.INodeData
        {
            public Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree1D> BlendTree;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.BlendTree1DNode.KernelData, Unity.Animation.BlendTree1DNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.BlendTree1DNode.KernelData data, ref Unity.Animation.BlendTree1DNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Blend", @"Blend parameter value", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.BlendTree1DNode, float> BlendParameter;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Current motion duration, used to compute normalized time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.BlendTree1DNode, float> Duration;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Normalized time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.BlendTree1DNode, float> NormalizedTime;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.BlendTree1DNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"BlendTree data", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.BlendTree1DNode, Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree1D>> BlendTree;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.BlendTree1DNode, Unity.Animation.Rig> Rig;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageOutput<Unity.Animation.BlendTree1DNode, Unity.Animation.Rig> RigOut;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Blend Trees", @"Evaluates a 2D BlendTree based on X and Y blend parameters", false)] public class BlendTree2DNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.BlendTree2DNode.Data, Unity.Animation.BlendTree2DNode.SimPorts, Unity.Animation.BlendTree2DNode.KernelData, Unity.Animation.BlendTree2DNode.KernelDefs, Unity.Animation.BlendTree2DNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.IMsgHandler<Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree2DSimpleDirectional>>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public BlendTree2DNode() {}
        protected virtual void Destroy(Unity.DataFlowGraph.NodeHandle handle);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree2DSimpleDirectional> blendTree);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        [Unity.DataFlowGraph.Managed] public struct Data : Unity.DataFlowGraph.INodeData
        {
            public Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree2DSimpleDirectional> BlendTree;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.BlendTree2DNode.KernelData, Unity.Animation.BlendTree2DNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.BlendTree2DNode.KernelData data, ref Unity.Animation.BlendTree2DNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Blend X", @"Blend parameter X value", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.BlendTree2DNode, float> BlendParameterX;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Blend Y", @"Blend parameter Y value", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.BlendTree2DNode, float> BlendParameterY;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Current motion duration, used to compute normalized time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.BlendTree2DNode, float> Duration;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Normalized time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.BlendTree2DNode, float> NormalizedTime;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.BlendTree2DNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"BlendTree data", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.BlendTree2DNode, Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree2DSimpleDirectional>> BlendTree;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.BlendTree2DNode, Unity.Animation.Rig> Rig;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageOutput<Unity.Animation.BlendTree2DNode, Unity.Animation.Rig> RigOut;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Mixers", @"Blends two animation streams given per channel weight values. Weight masks can be built using the WeightBuilderNode.", false)] public class ChannelWeightMixerNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.ChannelWeightMixerNode.Data, Unity.Animation.ChannelWeightMixerNode.SimPorts, Unity.Animation.ChannelWeightMixerNode.KernelData, Unity.Animation.ChannelWeightMixerNode.KernelDefs, Unity.Animation.ChannelWeightMixerNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public ChannelWeightMixerNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.ChannelWeightMixerNode.KernelData, Unity.Animation.ChannelWeightMixerNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.ChannelWeightMixerNode.KernelData data, ref Unity.Animation.ChannelWeightMixerNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfileMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream 0", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.ChannelWeightMixerNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input0;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream 1", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.ChannelWeightMixerNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input1;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.ChannelWeightMixerNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Blend weight that applies to all channels", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.ChannelWeightMixerNode, float> Weight;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Channel specific weights which are also modulated by input Weight", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.ChannelWeightMixerNode, Unity.DataFlowGraph.Buffer<Unity.Animation.WeightData>> WeightMasks;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ChannelWeightMixerNode, Unity.Animation.Rig> Rig;
        }
    }

    public struct ClipConfiguration
    {
        public Unity.Animation.ClipConfigurationMask Mask;
        public Unity.Animation.StringHash MotionID;
    }

    [System.Flags] public enum ClipConfigurationMask
    {
        public const Unity.Animation.ClipConfigurationMask BankPivot = 64;
        public const Unity.Animation.ClipConfigurationMask CycleRootMotion = 8;
        public const Unity.Animation.ClipConfigurationMask DeltaRootMotion = 16;
        public const Unity.Animation.ClipConfigurationMask LoopTime = 2;
        public const Unity.Animation.ClipConfigurationMask LoopValues = 4;
        public const Unity.Animation.ClipConfigurationMask NormalizedTime = 1;
        public const Unity.Animation.ClipConfigurationMask RootMotionFromVelocity = 32;
        public int value__;
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core", @"Base clip sampling node", true)] public class ClipNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.ClipNode.Data, Unity.Animation.ClipNode.SimPorts, Unity.Animation.ClipNode.KernelData, Unity.Animation.ClipNode.KernelDefs, Unity.Animation.ClipNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<bool>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.IMsgHandler<Unity.Entities.BlobAssetReference<Unity.Animation.Clip>>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public ClipNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref bool msg);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Entities.BlobAssetReference<Unity.Animation.Clip> clip);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.ClipNode.KernelData, Unity.Animation.ClipNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.ClipNode.KernelData data, ref Unity.Animation.ClipNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public int Additive;
            public Unity.Entities.BlobAssetReference<Unity.Animation.Clip> Clip;
            public Unity.Entities.BlobAssetReference<Unity.Animation.ClipInstance> ClipInstance;
            public Unity.Profiling.ProfilerMarker ProfileSampleClip;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.ClipNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Sample time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.ClipNode, float> Time;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Is this an additive clip", false, -1, false, 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ClipNode, bool> Additive;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"The clip asset to sample", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ClipNode, Unity.Entities.BlobAssetReference<Unity.Animation.Clip>> Clip;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Clip duration", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageOutput<Unity.Animation.ClipNode, float> Duration;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ClipNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core", @"Evaluates an animation clip given a clip configuration and time value", false)] public class ClipPlayerNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.ClipPlayerNode.Data, Unity.Animation.ClipPlayerNode.SimPorts, Unity.Animation.ClipPlayerNode.KernelData, Unity.Animation.ClipPlayerNode.KernelDefs, Unity.Animation.ClipPlayerNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<bool>, Unity.DataFlowGraph.IMsgHandler<float>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.ClipConfiguration>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.IMsgHandler<Unity.Entities.BlobAssetReference<Unity.Animation.Clip>>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public ClipPlayerNode() {}
        protected virtual void Destroy(Unity.DataFlowGraph.NodeHandle handle);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref bool msg);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref float msg);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.ClipConfiguration msg);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Entities.BlobAssetReference<Unity.Animation.Clip> clip);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.ClipPlayerNode.KernelData, Unity.Animation.ClipPlayerNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.ClipPlayerNode.KernelData data, ref Unity.Animation.ClipPlayerNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Delta time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.ClipPlayerNode, float> DeltaTime;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.ClipPlayerNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Time scale", @"Delta time scale factor", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.ClipPlayerNode, float> Speed;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Is an additive clip", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ClipPlayerNode, bool> Additive;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Clip to sample", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ClipPlayerNode, Unity.Entities.BlobAssetReference<Unity.Animation.Clip>> Clip;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Clip configuration data", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ClipPlayerNode, Unity.Animation.ClipConfiguration> Configuration;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ClipPlayerNode, Unity.Animation.Rig> Rig;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Time to sample the clip at", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ClipPlayerNode, float> Time;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Blend Trees", @"Computes 1D BlendTree weights based on parameter input", true)] public class ComputeBlendTree1DWeightsNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.ComputeBlendTree1DWeightsNode.Data, Unity.Animation.ComputeBlendTree1DWeightsNode.SimPorts, Unity.Animation.ComputeBlendTree1DWeightsNode.KernelData, Unity.Animation.ComputeBlendTree1DWeightsNode.KernelDefs, Unity.Animation.ComputeBlendTree1DWeightsNode.Kernel>, Unity.DataFlowGraph.IMsgHandler<Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree1D>>
    {
        public ComputeBlendTree1DWeightsNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree1D> blendTree);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.ComputeBlendTree1DWeightsNode.KernelData, Unity.Animation.ComputeBlendTree1DWeightsNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.ComputeBlendTree1DWeightsNode.KernelData data, ref Unity.Animation.ComputeBlendTree1DWeightsNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree1D> BlendTree;
            public Unity.Profiling.ProfilerMarker ProfileMarker;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Blend parameter value", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.ComputeBlendTree1DWeightsNode, float> BlendParameter;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Current motion duration", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.ComputeBlendTree1DWeightsNode, float> Duration;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Motion Duration", @"Duration of each motion used by this BlendTree", false, -1, , 0, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.ComputeBlendTree1DWeightsNode, float>> MotionDurations;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting motion weights, size of buffer is equal to the amount of motions", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.ComputeBlendTree1DWeightsNode, Unity.DataFlowGraph.Buffer<float>> Weights;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"BlendTree 1D properties", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ComputeBlendTree1DWeightsNode, Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree1D>> BlendTree;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Blend Trees", @"Computes 2D BlendTree weights based on parameter input", true)] public class ComputeBlendTree2DWeightsNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.ComputeBlendTree2DWeightsNode.Data, Unity.Animation.ComputeBlendTree2DWeightsNode.SimPorts, Unity.Animation.ComputeBlendTree2DWeightsNode.KernelData, Unity.Animation.ComputeBlendTree2DWeightsNode.KernelDefs, Unity.Animation.ComputeBlendTree2DWeightsNode.Kernel>, Unity.DataFlowGraph.IMsgHandler<Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree2DSimpleDirectional>>
    {
        public ComputeBlendTree2DWeightsNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree2DSimpleDirectional> blendTree);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.ComputeBlendTree2DWeightsNode.KernelData, Unity.Animation.ComputeBlendTree2DWeightsNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.ComputeBlendTree2DWeightsNode.KernelData data, ref Unity.Animation.ComputeBlendTree2DWeightsNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree2DSimpleDirectional> BlendTree;
            public Unity.Profiling.ProfilerMarker ProfileMarker;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Blend parameter X value", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.ComputeBlendTree2DWeightsNode, float> BlendParameterX;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Blend parameter Y value", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.ComputeBlendTree2DWeightsNode, float> BlendParameterY;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Current motion duration", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.ComputeBlendTree2DWeightsNode, float> Duration;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Motion Duration", @"Duration of each motion used by this BlendTree", false, -1, , 0, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.ComputeBlendTree2DWeightsNode, float>> MotionDurations;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting motion weights, size of buffer is equal to the amount of motions", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.ComputeBlendTree2DWeightsNode, Unity.DataFlowGraph.Buffer<float>> Weights;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"BlendTree 2D properties", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ComputeBlendTree2DWeightsNode, Unity.Entities.BlobAssetReference<Unity.Animation.BlendTree2DSimpleDirectional>> BlendTree;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core", @"Evaluates a clip based on the clip configuration mask", true)] public class ConfigurableClipNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.ConfigurableClipNode.Data, Unity.Animation.ConfigurableClipNode.SimPorts, Unity.Animation.ConfigurableClipNode.KernelData, Unity.Animation.ConfigurableClipNode.KernelDefs, Unity.Animation.ConfigurableClipNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<bool>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.ClipConfiguration>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.IMsgHandler<Unity.Entities.BlobAssetReference<Unity.Animation.Clip>>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public ConfigurableClipNode() {}
        protected virtual void Destroy(Unity.DataFlowGraph.NodeHandle handle);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref bool msg);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.ClipConfiguration msg);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Entities.BlobAssetReference<Unity.Animation.Clip> clip);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
            public Unity.Entities.BlobAssetReference<Unity.Animation.Clip> Clip;
            public bool IsAdditive;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.ConfigurableClipNode.KernelData, Unity.Animation.ConfigurableClipNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.ConfigurableClipNode.KernelData data, ref Unity.Animation.ConfigurableClipNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.ConfigurableClipNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Unbound time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.ConfigurableClipNode, float> Time;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Is this an additive clip", false, -1, false, 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ConfigurableClipNode, bool> Additive;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Clip to sample", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ConfigurableClipNode, Unity.Entities.BlobAssetReference<Unity.Animation.Clip>> Clip;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Clip configuration data", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ConfigurableClipNode, Unity.Animation.ClipConfiguration> Configuration;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ConfigurableClipNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Convert float4x4 to LocalToParent component data", false)] public class ConvertFloat4x4ToLocalToParentComponentNode : Unity.Animation.ConvertToBase<Unity.Animation.ConvertFloat4x4ToLocalToParentComponentNode, Unity.Mathematics.float4x4, Unity.Transforms.LocalToParent, Unity.Animation.ConvertFloat4x4ToLocalToParentComponentNode.Kernel>
    {
        public ConvertFloat4x4ToLocalToParentComponentNode() {}
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.ConvertToBase<Unity.Animation.ConvertFloat4x4ToLocalToParentComponentNode, Unity.Mathematics.float4x4, Unity.Transforms.LocalToParent, Unity.Animation.ConvertFloat4x4ToLocalToParentComponentNode.Kernel>, Unity.Animation.ConvertToBase<Unity.Animation.ConvertFloat4x4ToLocalToParentComponentNode, Unity.Mathematics.float4x4, Unity.Transforms.LocalToParent, Unity.Animation.ConvertFloat4x4ToLocalToParentComponentNode.Kernel>>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext ctx, Unity.Animation.ConvertToBase<Unity.Animation.ConvertFloat4x4ToLocalToParentComponentNode, Unity.Mathematics.float4x4, Unity.Transforms.LocalToParent, Unity.Animation.ConvertFloat4x4ToLocalToParentComponentNode.Kernel> data, ref Unity.Animation.ConvertToBase<Unity.Animation.ConvertFloat4x4ToLocalToParentComponentNode, Unity.Mathematics.float4x4, Unity.Transforms.LocalToParent, Unity.Animation.ConvertFloat4x4ToLocalToParentComponentNode.Kernel> ports);
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Convert float4x4 to LocalToWorld component data", false)] public class ConvertFloat4x4ToLocalToWorldComponentNode : Unity.Animation.ConvertToBase<Unity.Animation.ConvertFloat4x4ToLocalToWorldComponentNode, Unity.Mathematics.float4x4, Unity.Transforms.LocalToWorld, Unity.Animation.ConvertFloat4x4ToLocalToWorldComponentNode.Kernel>
    {
        public ConvertFloat4x4ToLocalToWorldComponentNode() {}
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.ConvertToBase<Unity.Animation.ConvertFloat4x4ToLocalToWorldComponentNode, Unity.Mathematics.float4x4, Unity.Transforms.LocalToWorld, Unity.Animation.ConvertFloat4x4ToLocalToWorldComponentNode.Kernel>, Unity.Animation.ConvertToBase<Unity.Animation.ConvertFloat4x4ToLocalToWorldComponentNode, Unity.Mathematics.float4x4, Unity.Transforms.LocalToWorld, Unity.Animation.ConvertFloat4x4ToLocalToWorldComponentNode.Kernel>>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext ctx, Unity.Animation.ConvertToBase<Unity.Animation.ConvertFloat4x4ToLocalToWorldComponentNode, Unity.Mathematics.float4x4, Unity.Transforms.LocalToWorld, Unity.Animation.ConvertFloat4x4ToLocalToWorldComponentNode.Kernel> data, ref Unity.Animation.ConvertToBase<Unity.Animation.ConvertFloat4x4ToLocalToWorldComponentNode, Unity.Mathematics.float4x4, Unity.Transforms.LocalToWorld, Unity.Animation.ConvertFloat4x4ToLocalToWorldComponentNode.Kernel> ports);
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Convert LocalToParent component data to float4x4", false)] public class ConvertLocalToParentComponentToFloat4x4Node : Unity.Animation.ConvertToBase<Unity.Animation.ConvertLocalToParentComponentToFloat4x4Node, Unity.Transforms.LocalToParent, Unity.Mathematics.float4x4, Unity.Animation.ConvertLocalToParentComponentToFloat4x4Node.Kernel>
    {
        public ConvertLocalToParentComponentToFloat4x4Node() {}
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.ConvertToBase<Unity.Animation.ConvertLocalToParentComponentToFloat4x4Node, Unity.Transforms.LocalToParent, Unity.Mathematics.float4x4, Unity.Animation.ConvertLocalToParentComponentToFloat4x4Node.Kernel>, Unity.Animation.ConvertToBase<Unity.Animation.ConvertLocalToParentComponentToFloat4x4Node, Unity.Transforms.LocalToParent, Unity.Mathematics.float4x4, Unity.Animation.ConvertLocalToParentComponentToFloat4x4Node.Kernel>>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext ctx, Unity.Animation.ConvertToBase<Unity.Animation.ConvertLocalToParentComponentToFloat4x4Node, Unity.Transforms.LocalToParent, Unity.Mathematics.float4x4, Unity.Animation.ConvertLocalToParentComponentToFloat4x4Node.Kernel> data, ref Unity.Animation.ConvertToBase<Unity.Animation.ConvertLocalToParentComponentToFloat4x4Node, Unity.Transforms.LocalToParent, Unity.Mathematics.float4x4, Unity.Animation.ConvertLocalToParentComponentToFloat4x4Node.Kernel> ports);
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Convert LocalToWorld component data to float4x4", false)] public class ConvertLocalToWorldComponentToFloat4x4Node : Unity.Animation.ConvertToBase<Unity.Animation.ConvertLocalToWorldComponentToFloat4x4Node, Unity.Transforms.LocalToWorld, Unity.Mathematics.float4x4, Unity.Animation.ConvertLocalToWorldComponentToFloat4x4Node.Kernel>
    {
        public ConvertLocalToWorldComponentToFloat4x4Node() {}
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.ConvertToBase<Unity.Animation.ConvertLocalToWorldComponentToFloat4x4Node, Unity.Transforms.LocalToWorld, Unity.Mathematics.float4x4, Unity.Animation.ConvertLocalToWorldComponentToFloat4x4Node.Kernel>, Unity.Animation.ConvertToBase<Unity.Animation.ConvertLocalToWorldComponentToFloat4x4Node, Unity.Transforms.LocalToWorld, Unity.Mathematics.float4x4, Unity.Animation.ConvertLocalToWorldComponentToFloat4x4Node.Kernel>>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext ctx, Unity.Animation.ConvertToBase<Unity.Animation.ConvertLocalToWorldComponentToFloat4x4Node, Unity.Transforms.LocalToWorld, Unity.Mathematics.float4x4, Unity.Animation.ConvertLocalToWorldComponentToFloat4x4Node.Kernel> data, ref Unity.Animation.ConvertToBase<Unity.Animation.ConvertLocalToWorldComponentToFloat4x4Node, Unity.Transforms.LocalToWorld, Unity.Mathematics.float4x4, Unity.Animation.ConvertLocalToWorldComponentToFloat4x4Node.Kernel> ports);
        }
    }

    public abstract class ConvertToBase<TFinalNodeDefinition, TInput, TOutput, TKernel> : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.ConvertToBase<TFinalNodeDefinition, TInput, TOutput, TKernel>, Unity.Animation.ConvertToBase<TFinalNodeDefinition, TInput, TOutput, TKernel>, Unity.Animation.ConvertToBase<TFinalNodeDefinition, TInput, TOutput, TKernel>, Unity.Animation.ConvertToBase<TFinalNodeDefinition, TInput, TOutput, TKernel>, TKernel> where TFinalNodeDefinition : Unity.DataFlowGraph.NodeDefinition where TInput : System.ValueType, new() where TOutput : System.ValueType, new() where TKernel : System.ValueType, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.ConvertToBase<TFinalNodeDefinition, TInput, TOutput, TKernel>, Unity.Animation.ConvertToBase<TFinalNodeDefinition, TInput, TOutput, TKernel>>, new()
    {
        protected ConvertToBase() {}
        public struct SimPorts<TFinalNodeDefinition, TInput, TOutput, TKernel> : Unity.DataFlowGraph.ISimulationPortDefinition where TFinalNodeDefinition : Unity.DataFlowGraph.NodeDefinition where TInput : System.ValueType, new() where TOutput : System.ValueType, new() where TKernel : System.ValueType, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.ConvertToBase<TFinalNodeDefinition, TInput, TOutput, TKernel>, Unity.Animation.ConvertToBase<TFinalNodeDefinition, TInput, TOutput, TKernel>>, new()
        {
        }
        public struct KernelDefs<TFinalNodeDefinition, TInput, TOutput, TKernel> : Unity.DataFlowGraph.IKernelPortDefinition where TFinalNodeDefinition : Unity.DataFlowGraph.NodeDefinition where TInput : System.ValueType, new() where TOutput : System.ValueType, new() where TKernel : System.ValueType, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.ConvertToBase<TFinalNodeDefinition, TInput, TOutput, TKernel>, Unity.Animation.ConvertToBase<TFinalNodeDefinition, TInput, TOutput, TKernel>>, new()
        {
            public Unity.DataFlowGraph.DataInput<TFinalNodeDefinition, TInput> Input;
            public Unity.DataFlowGraph.DataOutput<TFinalNodeDefinition, TOutput> Output;
        }
        public struct Data<TFinalNodeDefinition, TInput, TOutput, TKernel> : Unity.DataFlowGraph.INodeData where TFinalNodeDefinition : Unity.DataFlowGraph.NodeDefinition where TInput : System.ValueType, new() where TOutput : System.ValueType, new() where TKernel : System.ValueType, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.ConvertToBase<TFinalNodeDefinition, TInput, TOutput, TKernel>, Unity.Animation.ConvertToBase<TFinalNodeDefinition, TInput, TOutput, TKernel>>, new()
        {
        }
        public struct KernelData<TFinalNodeDefinition, TInput, TOutput, TKernel> : Unity.DataFlowGraph.IKernelData where TFinalNodeDefinition : Unity.DataFlowGraph.NodeDefinition where TInput : System.ValueType, new() where TOutput : System.ValueType, new() where TKernel : System.ValueType, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.ConvertToBase<TFinalNodeDefinition, TInput, TOutput, TKernel>, Unity.Animation.ConvertToBase<TFinalNodeDefinition, TInput, TOutput, TKernel>>, new()
        {
            public Unity.DataFlowGraph.DataInput<TFinalNodeDefinition, TInput> Input;
            public Unity.DataFlowGraph.DataOutput<TFinalNodeDefinition, TOutput> Output;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Root Motion", @"Computes and sets the total root motion offset amount based on the number of cycles for a given clip. This node is internally used by the UberClipNode.", false)] public class CycleRootMotionNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.CycleRootMotionNode.Data, Unity.Animation.CycleRootMotionNode.SimPorts, Unity.Animation.CycleRootMotionNode.KernelData, Unity.Animation.CycleRootMotionNode.KernelDefs, Unity.Animation.CycleRootMotionNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public CycleRootMotionNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.CycleRootMotionNode.KernelData, Unity.Animation.CycleRootMotionNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.CycleRootMotionNode.KernelData data, ref Unity.Animation.CycleRootMotionNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfileMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Clip cycle count", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.CycleRootMotionNode, int> Cycle;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"The current animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.CycleRootMotionNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream with updated root motion values", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.CycleRootMotionNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Animation stream at the start of the clip, when t = 0", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.CycleRootMotionNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Start;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Animation stream at the end of the clip, when t = duration", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.CycleRootMotionNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Stop;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.CycleRootMotionNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Outputs the default values of a RigDefinition as an animation stream (i.e. the bind pose)", false)] public class DefaultValuesNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.DefaultValuesNode.Data, Unity.Animation.DefaultValuesNode.SimPorts, Unity.Animation.DefaultValuesNode.KernelData, Unity.Animation.DefaultValuesNode.KernelDefs, Unity.Animation.DefaultValuesNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public DefaultValuesNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.DefaultValuesNode.KernelData, Unity.Animation.DefaultValuesNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.DefaultValuesNode.KernelData data, ref Unity.Animation.DefaultValuesNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Default stream values", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.DefaultValuesNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.DefaultValuesNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Computes the delta animation stream given two input streams", false)] public class DeltaPoseNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.DeltaPoseNode.Data, Unity.Animation.DeltaPoseNode.SimPorts, Unity.Animation.DeltaPoseNode.KernelData, Unity.Animation.DeltaPoseNode.KernelDefs, Unity.Animation.DeltaPoseNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public DeltaPoseNode() {}
        protected virtual void Destroy(Unity.DataFlowGraph.NodeHandle handle);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
            public Unity.DataFlowGraph.NodeHandle<Unity.Animation.AddPoseNode> AddNode;
            public Unity.DataFlowGraph.NodeHandle<Unity.Animation.InversePoseNode> InverseNode;
            public Unity.DataFlowGraph.NodeHandle<Unity.Animation.SimPassThroughNode<Unity.Animation.Rig>> RigNode;
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.DeltaPoseNode.KernelData, Unity.Animation.DeltaPoseNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.DeltaPoseNode.KernelData data, ref Unity.Animation.DeltaPoseNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.DeltaPoseNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting delta stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.DeltaPoseNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Stream to substract", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.DeltaPoseNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Subtract;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.DeltaPoseNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Root Motion", @"Computes the delta root motion from a previous and current animation stream. This node is internally used by the UberClipNode.", false)] public class DeltaRootMotionNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.DeltaRootMotionNode.Data, Unity.Animation.DeltaRootMotionNode.SimPorts, Unity.Animation.DeltaRootMotionNode.KernelData, Unity.Animation.DeltaRootMotionNode.KernelDefs, Unity.Animation.DeltaRootMotionNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public DeltaRootMotionNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.DeltaRootMotionNode.KernelData, Unity.Animation.DeltaRootMotionNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.DeltaRootMotionNode.KernelData data, ref Unity.Animation.DeltaRootMotionNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfileMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Current animation stream with root motion", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.DeltaRootMotionNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Current;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream with updated delta root motion values", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.DeltaRootMotionNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Previous animation stream with root motion", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.DeltaRootMotionNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Previous;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.DeltaRootMotionNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Time", @"Computes delta time", false)] public class DeltaTimeNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.DeltaTimeNode.Data, Unity.Animation.DeltaTimeNode.SimPorts, Unity.Animation.DeltaTimeNode.KernelData, Unity.Animation.DeltaTimeNode.KernelDefs, Unity.Animation.DeltaTimeNode.Kernel>
    {
        public DeltaTimeNode() {}
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        protected virtual void OnUpdate(Unity.DataFlowGraph.UpdateContext& modreq(System.Runtime.InteropServices.InAttribute) ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.DeltaTimeNode.KernelData, Unity.Animation.DeltaTimeNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.DeltaTimeNode.KernelData data, ref Unity.Animation.DeltaTimeNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public float DeltaTime;
            public Unity.Profiling.ProfilerMarker ProfileDeltaTime;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Delta time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.DeltaTimeNode, float> DeltaTime;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
        }
    }

    public static class DFGUtils
    {
        public static Unity.Collections.NativeArray<Unity.Animation.AnimatedData> GetGraphValueTempNativeBuffer(Unity.DataFlowGraph.NodeSet set, Unity.DataFlowGraph.GraphValue<Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> graphValueBuffer);
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core", @"Samples an AnimationCurve at a given time", false)] public class EvaluateCurveNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.EvaluateCurveNode.Data, Unity.Animation.EvaluateCurveNode.SimPorts, Unity.Animation.EvaluateCurveNode.KernelData, Unity.Animation.EvaluateCurveNode.KernelDefs, Unity.Animation.EvaluateCurveNode.Kernel>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.AnimationCurve>
    {
        public EvaluateCurveNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.AnimationCurve curve);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.EvaluateCurveNode.KernelData, Unity.Animation.EvaluateCurveNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.EvaluateCurveNode.KernelData data, ref Unity.Animation.EvaluateCurveNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Animation.AnimationCurve AnimationCurve;
            public Unity.Profiling.ProfilerMarker ProfileMarker;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Curve value at given time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.EvaluateCurveNode, float> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Sample time", false, -1, 0, 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.EvaluateCurveNode, float> Time;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"The AnimationCurve to sample", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.EvaluateCurveNode, Unity.Animation.AnimationCurve> AnimationCurve;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"", @"", true)] public class FloatAddNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.FloatAddNode.Data, Unity.Animation.FloatAddNode.SimPorts, Unity.Animation.FloatAddNode.KernelData, Unity.Animation.FloatAddNode.KernelDefs, Unity.Animation.FloatAddNode.Kernel>
    {
        public FloatAddNode() {}
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.FloatAddNode.KernelData, Unity.Animation.FloatAddNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.FloatAddNode.KernelData data, ref Unity.Animation.FloatAddNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfileFloatAdd;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            public Unity.DataFlowGraph.DataInput<Unity.Animation.FloatAddNode, float> InputA;
            public Unity.DataFlowGraph.DataInput<Unity.Animation.FloatAddNode, float> InputB;
            public Unity.DataFlowGraph.DataOutput<Unity.Animation.FloatAddNode, float> Output;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"", @"", true)] public class FloatMulNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.FloatMulNode.Data, Unity.Animation.FloatMulNode.SimPorts, Unity.Animation.FloatMulNode.KernelData, Unity.Animation.FloatMulNode.KernelDefs, Unity.Animation.FloatMulNode.Kernel>
    {
        public FloatMulNode() {}
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.FloatMulNode.KernelData, Unity.Animation.FloatMulNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.FloatMulNode.KernelData data, ref Unity.Animation.FloatMulNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfileFloatMul;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            public Unity.DataFlowGraph.DataInput<Unity.Animation.FloatMulNode, float> InputA;
            public Unity.DataFlowGraph.DataInput<Unity.Animation.FloatMulNode, float> InputB;
            public Unity.DataFlowGraph.DataOutput<Unity.Animation.FloatMulNode, float> Output;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"", @"", true)] public class FloatRcpNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.FloatRcpNode.Data, Unity.Animation.FloatRcpNode.SimPorts, Unity.Animation.FloatRcpNode.KernelData, Unity.Animation.FloatRcpNode.KernelDefs, Unity.Animation.FloatRcpNode.Kernel>
    {
        public FloatRcpNode() {}
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.FloatRcpNode.KernelData, Unity.Animation.FloatRcpNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.FloatRcpNode.KernelData data, ref Unity.Animation.FloatRcpNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            public Unity.DataFlowGraph.DataInput<Unity.Animation.FloatRcpNode, float> Input;
            public Unity.DataFlowGraph.DataOutput<Unity.Animation.FloatRcpNode, float> Output;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"", @"", true)] public class FloatRcpSimNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.FloatRcpSimNode.Data, Unity.Animation.FloatRcpSimNode.SimPorts>, Unity.DataFlowGraph.IMsgHandler<float>
    {
        public FloatRcpSimNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref float msg);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            public Unity.DataFlowGraph.MessageInput<Unity.Animation.FloatRcpSimNode, float> Input;
            public Unity.DataFlowGraph.MessageOutput<Unity.Animation.FloatRcpSimNode, float> Output;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"", @"", true)] public class FloatSubNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.FloatSubNode.Data, Unity.Animation.FloatSubNode.SimPorts, Unity.Animation.FloatSubNode.KernelData, Unity.Animation.FloatSubNode.KernelDefs, Unity.Animation.FloatSubNode.Kernel>
    {
        public FloatSubNode() {}
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.FloatSubNode.KernelData, Unity.Animation.FloatSubNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.FloatSubNode.KernelData data, ref Unity.Animation.FloatSubNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfileFloatSub;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            public Unity.DataFlowGraph.DataInput<Unity.Animation.FloatSubNode, float> InputA;
            public Unity.DataFlowGraph.DataInput<Unity.Animation.FloatSubNode, float> InputB;
            public Unity.DataFlowGraph.DataOutput<Unity.Animation.FloatSubNode, float> Output;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Gets a float value from the AnimationStream", false)] public class GetAnimationStreamFloatNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.GetAnimationStreamFloatNode.Data, Unity.Animation.GetAnimationStreamFloatNode.SimPorts, Unity.Animation.GetAnimationStreamFloatNode.KernelData, Unity.Animation.GetAnimationStreamFloatNode.KernelDefs, Unity.Animation.GetAnimationStreamFloatNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public GetAnimationStreamFloatNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.GetAnimationStreamFloatNode.KernelData, Unity.Animation.GetAnimationStreamFloatNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.GetAnimationStreamFloatNode.KernelData data, ref Unity.Animation.GetAnimationStreamFloatNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Index in stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.GetAnimationStreamFloatNode, int> Index;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.GetAnimationStreamFloatNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Value", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.GetAnimationStreamFloatNode, float> Output;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.GetAnimationStreamFloatNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Gets an integer value from the AnimationStream", false)] public class GetAnimationStreamIntNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.GetAnimationStreamIntNode.Data, Unity.Animation.GetAnimationStreamIntNode.SimPorts, Unity.Animation.GetAnimationStreamIntNode.KernelData, Unity.Animation.GetAnimationStreamIntNode.KernelDefs, Unity.Animation.GetAnimationStreamIntNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public GetAnimationStreamIntNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.GetAnimationStreamIntNode.KernelData, Unity.Animation.GetAnimationStreamIntNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.GetAnimationStreamIntNode.KernelData data, ref Unity.Animation.GetAnimationStreamIntNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Index in stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.GetAnimationStreamIntNode, int> Index;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.GetAnimationStreamIntNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Value", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.GetAnimationStreamIntNode, int> Output;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.GetAnimationStreamIntNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Gets the local to parent information of a bone in the AnimationStream", false)] public class GetAnimationStreamLocalToParentNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.GetAnimationStreamLocalToParentNode.Data, Unity.Animation.GetAnimationStreamLocalToParentNode.SimPorts, Unity.Animation.GetAnimationStreamLocalToParentNode.KernelData, Unity.Animation.GetAnimationStreamLocalToParentNode.KernelDefs, Unity.Animation.GetAnimationStreamLocalToParentNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public GetAnimationStreamLocalToParentNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.GetAnimationStreamLocalToParentNode.KernelData, Unity.Animation.GetAnimationStreamLocalToParentNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.GetAnimationStreamLocalToParentNode.KernelData data, ref Unity.Animation.GetAnimationStreamLocalToParentNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Bone index in stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.GetAnimationStreamLocalToParentNode, int> Index;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.GetAnimationStreamLocalToParentNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Local to parent rotation", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.GetAnimationStreamLocalToParentNode, Unity.Mathematics.quaternion> Rotation;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Local to parent scale", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.GetAnimationStreamLocalToParentNode, Unity.Mathematics.float3> Scale;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Local to parent transform", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.GetAnimationStreamLocalToParentNode, Unity.Mathematics.float4x4> Transform;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Local to parent translation", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.GetAnimationStreamLocalToParentNode, Unity.Mathematics.float3> Translation;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.GetAnimationStreamLocalToParentNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Gets the local to root information of a bone in the AnimationStream", false)] public class GetAnimationStreamLocalToRootNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.GetAnimationStreamLocalToRootNode.Data, Unity.Animation.GetAnimationStreamLocalToRootNode.SimPorts, Unity.Animation.GetAnimationStreamLocalToRootNode.KernelData, Unity.Animation.GetAnimationStreamLocalToRootNode.KernelDefs, Unity.Animation.GetAnimationStreamLocalToRootNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public GetAnimationStreamLocalToRootNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.GetAnimationStreamLocalToRootNode.KernelData, Unity.Animation.GetAnimationStreamLocalToRootNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.GetAnimationStreamLocalToRootNode.KernelData data, ref Unity.Animation.GetAnimationStreamLocalToRootNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Bone index in stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.GetAnimationStreamLocalToRootNode, int> Index;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.GetAnimationStreamLocalToRootNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Local to root rotation", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.GetAnimationStreamLocalToRootNode, Unity.Mathematics.quaternion> Rotation;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Local to root transform", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.GetAnimationStreamLocalToRootNode, Unity.Mathematics.float4x4> Transform;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Local to root translation", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.GetAnimationStreamLocalToRootNode, Unity.Mathematics.float3> Translation;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.GetAnimationStreamLocalToRootNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Gets a value given an index from a buffer", false)] public class GetBufferElementValueNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.GetBufferElementValueNode.Data, Unity.Animation.GetBufferElementValueNode.SimPorts, Unity.Animation.GetBufferElementValueNode.KernelData, Unity.Animation.GetBufferElementValueNode.KernelDefs, Unity.Animation.GetBufferElementValueNode.Kernel>
    {
        public GetBufferElementValueNode() {}
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.GetBufferElementValueNode.KernelData, Unity.Animation.GetBufferElementValueNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.GetBufferElementValueNode.KernelData data, ref Unity.Animation.GetBufferElementValueNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfileMarker;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Index in buffer", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.GetBufferElementValueNode, int> Index;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input buffer", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.GetBufferElementValueNode, Unity.DataFlowGraph.Buffer<float>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Value", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.GetBufferElementValueNode, float> Output;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
        }
    }

    public struct GraphHandle : System.IEquatable<Unity.Animation.GraphHandle>
    {
        public virtual bool Equals(object obj);
        public virtual bool Equals(Unity.Animation.GraphHandle other);
        public virtual int GetHashCode();
        public static bool operator ==(Unity.Animation.GraphHandle lhs, Unity.Animation.GraphHandle rhs);
        public static bool operator !=(Unity.Animation.GraphHandle lhs, Unity.Animation.GraphHandle rhs);
    }

    public interface IAnimationSystem
    {
        public abstract int RefCount { get; }
        public abstract Unity.DataFlowGraph.NodeSet Set { get; }
        public abstract void AddRef();
        public abstract Unity.Animation.GraphHandle CreateGraph();
        public abstract Unity.DataFlowGraph.NodeHandle<T> CreateNode<T>(Unity.Animation.GraphHandle graph) where T : Unity.DataFlowGraph.NodeDefinition, new();
        public abstract Unity.DataFlowGraph.NodeHandle<Unity.DataFlowGraph.ComponentNode> CreateNode(Unity.Animation.GraphHandle graph, Unity.Entities.Entity entity);
        public abstract void Dispose(Unity.Animation.GraphHandle graph);
        public abstract void RemoveRef();
    }

    public interface IAnimationSystem<TTag> : Unity.Animation.IAnimationSystem where TTag : System.ValueType, Unity.Animation.IAnimationSystemTag, new()
    {
        public abstract TTag TagComponent { get; }
    }

    public interface IAnimationSystemTag : Unity.Entities.IComponentData
    {
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Root Motion", @"Extracts motion from a specified transform and projects it's values on the root transform. This node is internally used by the UberClipNode.", false)] public class InPlaceMotionNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.InPlaceMotionNode.Data, Unity.Animation.InPlaceMotionNode.SimPorts, Unity.Animation.InPlaceMotionNode.KernelData, Unity.Animation.InPlaceMotionNode.KernelDefs, Unity.Animation.InPlaceMotionNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.ClipConfiguration>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public InPlaceMotionNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.ClipConfiguration msg);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.InPlaceMotionNode.KernelData, Unity.Animation.InPlaceMotionNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.InPlaceMotionNode.KernelData data, ref Unity.Animation.InPlaceMotionNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Animation.ClipConfiguration Configuration;
            public Unity.Profiling.ProfilerMarker ProfileMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
            public int RotationIndex;
            public int TranslationIndex;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"The current animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.InPlaceMotionNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream with updated root transform", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.InPlaceMotionNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Clip configuration mask", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.InPlaceMotionNode, Unity.Animation.ClipConfiguration> Configuration;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.InPlaceMotionNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Computes the inverse animation stream", false)] public class InversePoseNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.InversePoseNode.Data, Unity.Animation.InversePoseNode.SimPorts, Unity.Animation.InversePoseNode.KernelData, Unity.Animation.InversePoseNode.KernelDefs, Unity.Animation.InversePoseNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public InversePoseNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.InversePoseNode.KernelData, Unity.Animation.InversePoseNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.InversePoseNode.KernelData data, ref Unity.Animation.InversePoseNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfileMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.InversePoseNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting inversed stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.InversePoseNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.InversePoseNode, Unity.Animation.Rig> Rig;
        }
    }

    public interface IRigContextHandler : Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"", @"", true)] public abstract class KernelPassThroughNode<TFinalNodeDefinition, T, TKernel> : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.KernelPassThroughNode<TFinalNodeDefinition, T, TKernel>, Unity.Animation.KernelPassThroughNode<TFinalNodeDefinition, T, TKernel>, Unity.Animation.KernelPassThroughNode<TFinalNodeDefinition, T, TKernel>, Unity.Animation.KernelPassThroughNode<TFinalNodeDefinition, T, TKernel>, TKernel> where TFinalNodeDefinition : Unity.DataFlowGraph.NodeDefinition where T : System.ValueType, new() where TKernel : System.ValueType, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.KernelPassThroughNode<TFinalNodeDefinition, T, TKernel>, Unity.Animation.KernelPassThroughNode<TFinalNodeDefinition, T, TKernel>>, new()
    {
        protected KernelPassThroughNode() {}
        public struct SimPorts<TFinalNodeDefinition, T, TKernel> : Unity.DataFlowGraph.ISimulationPortDefinition where TFinalNodeDefinition : Unity.DataFlowGraph.NodeDefinition where T : System.ValueType, new() where TKernel : System.ValueType, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.KernelPassThroughNode<TFinalNodeDefinition, T, TKernel>, Unity.Animation.KernelPassThroughNode<TFinalNodeDefinition, T, TKernel>>, new()
        {
        }
        public struct KernelDefs<TFinalNodeDefinition, T, TKernel> : Unity.DataFlowGraph.IKernelPortDefinition where TFinalNodeDefinition : Unity.DataFlowGraph.NodeDefinition where T : System.ValueType, new() where TKernel : System.ValueType, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.KernelPassThroughNode<TFinalNodeDefinition, T, TKernel>, Unity.Animation.KernelPassThroughNode<TFinalNodeDefinition, T, TKernel>>, new()
        {
            public Unity.DataFlowGraph.DataInput<TFinalNodeDefinition, T> Input;
            public Unity.DataFlowGraph.DataOutput<TFinalNodeDefinition, T> Output;
        }
        public struct Data<TFinalNodeDefinition, T, TKernel> : Unity.DataFlowGraph.INodeData where TFinalNodeDefinition : Unity.DataFlowGraph.NodeDefinition where T : System.ValueType, new() where TKernel : System.ValueType, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.KernelPassThroughNode<TFinalNodeDefinition, T, TKernel>, Unity.Animation.KernelPassThroughNode<TFinalNodeDefinition, T, TKernel>>, new()
        {
        }
        public struct KernelData<TFinalNodeDefinition, T, TKernel> : Unity.DataFlowGraph.IKernelData where TFinalNodeDefinition : Unity.DataFlowGraph.NodeDefinition where T : System.ValueType, new() where TKernel : System.ValueType, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.KernelPassThroughNode<TFinalNodeDefinition, T, TKernel>, Unity.Animation.KernelPassThroughNode<TFinalNodeDefinition, T, TKernel>>, new()
        {
            public Unity.Profiling.ProfilerMarker ProfilePassThrough;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"", @"", true)] public abstract class KernelPassThroughNodeBuffer<TFinalNodeDefinition, T, TKernel> : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.KernelPassThroughNodeBuffer<TFinalNodeDefinition, T, TKernel>, Unity.Animation.KernelPassThroughNodeBuffer<TFinalNodeDefinition, T, TKernel>, Unity.Animation.KernelPassThroughNodeBuffer<TFinalNodeDefinition, T, TKernel>, Unity.Animation.KernelPassThroughNodeBuffer<TFinalNodeDefinition, T, TKernel>, TKernel>, Unity.DataFlowGraph.IMsgHandler<int> where TFinalNodeDefinition : Unity.DataFlowGraph.NodeDefinition, Unity.DataFlowGraph.IMsgHandler<int> where T : System.ValueType, new() where TKernel : System.ValueType, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.KernelPassThroughNodeBuffer<TFinalNodeDefinition, T, TKernel>, Unity.Animation.KernelPassThroughNodeBuffer<TFinalNodeDefinition, T, TKernel>>, new()
    {
        protected KernelPassThroughNodeBuffer() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref int msg);
        public struct SimPorts<TFinalNodeDefinition, T, TKernel> : Unity.DataFlowGraph.ISimulationPortDefinition where TFinalNodeDefinition : Unity.DataFlowGraph.NodeDefinition, Unity.DataFlowGraph.IMsgHandler<int> where T : System.ValueType, new() where TKernel : System.ValueType, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.KernelPassThroughNodeBuffer<TFinalNodeDefinition, T, TKernel>, Unity.Animation.KernelPassThroughNodeBuffer<TFinalNodeDefinition, T, TKernel>>, new()
        {
            public Unity.DataFlowGraph.MessageInput<TFinalNodeDefinition, int> BufferSize;
        }
        public struct KernelDefs<TFinalNodeDefinition, T, TKernel> : Unity.DataFlowGraph.IKernelPortDefinition where TFinalNodeDefinition : Unity.DataFlowGraph.NodeDefinition, Unity.DataFlowGraph.IMsgHandler<int> where T : System.ValueType, new() where TKernel : System.ValueType, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.KernelPassThroughNodeBuffer<TFinalNodeDefinition, T, TKernel>, Unity.Animation.KernelPassThroughNodeBuffer<TFinalNodeDefinition, T, TKernel>>, new()
        {
            public Unity.DataFlowGraph.DataInput<TFinalNodeDefinition, Unity.DataFlowGraph.Buffer<T>> Input;
            public Unity.DataFlowGraph.DataOutput<TFinalNodeDefinition, Unity.DataFlowGraph.Buffer<T>> Output;
        }
        public struct Data<TFinalNodeDefinition, T, TKernel> : Unity.DataFlowGraph.INodeData where TFinalNodeDefinition : Unity.DataFlowGraph.NodeDefinition, Unity.DataFlowGraph.IMsgHandler<int> where T : System.ValueType, new() where TKernel : System.ValueType, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.KernelPassThroughNodeBuffer<TFinalNodeDefinition, T, TKernel>, Unity.Animation.KernelPassThroughNodeBuffer<TFinalNodeDefinition, T, TKernel>>, new()
        {
        }
        public struct KernelData<TFinalNodeDefinition, T, TKernel> : Unity.DataFlowGraph.IKernelData where TFinalNodeDefinition : Unity.DataFlowGraph.NodeDefinition, Unity.DataFlowGraph.IMsgHandler<int> where T : System.ValueType, new() where TKernel : System.ValueType, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.KernelPassThroughNodeBuffer<TFinalNodeDefinition, T, TKernel>, Unity.Animation.KernelPassThroughNodeBuffer<TFinalNodeDefinition, T, TKernel>>, new()
        {
            public Unity.Profiling.ProfilerMarker ProfilePassThrough;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"", @"", true)] public class KernelPassThroughNodeBufferFloat : Unity.Animation.KernelPassThroughNodeBuffer<Unity.Animation.KernelPassThroughNodeBufferFloat, Unity.Animation.AnimatedData, Unity.Animation.KernelPassThroughNodeBufferFloat.Kernel>
    {
        public KernelPassThroughNodeBufferFloat() {}
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.KernelPassThroughNodeBuffer<Unity.Animation.KernelPassThroughNodeBufferFloat, Unity.Animation.AnimatedData, Unity.Animation.KernelPassThroughNodeBufferFloat.Kernel>, Unity.Animation.KernelPassThroughNodeBuffer<Unity.Animation.KernelPassThroughNodeBufferFloat, Unity.Animation.AnimatedData, Unity.Animation.KernelPassThroughNodeBufferFloat.Kernel>>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.KernelPassThroughNodeBuffer<Unity.Animation.KernelPassThroughNodeBufferFloat, Unity.Animation.AnimatedData, Unity.Animation.KernelPassThroughNodeBufferFloat.Kernel> data, ref Unity.Animation.KernelPassThroughNodeBuffer<Unity.Animation.KernelPassThroughNodeBufferFloat, Unity.Animation.AnimatedData, Unity.Animation.KernelPassThroughNodeBufferFloat.Kernel> ports);
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"", @"", true)] public class KernelPassThroughNodeFloat : Unity.Animation.KernelPassThroughNode<Unity.Animation.KernelPassThroughNodeFloat, float, Unity.Animation.KernelPassThroughNodeFloat.Kernel>
    {
        public KernelPassThroughNodeFloat() {}
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.KernelPassThroughNode<Unity.Animation.KernelPassThroughNodeFloat, float, Unity.Animation.KernelPassThroughNodeFloat.Kernel>, Unity.Animation.KernelPassThroughNode<Unity.Animation.KernelPassThroughNodeFloat, float, Unity.Animation.KernelPassThroughNodeFloat.Kernel>>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.KernelPassThroughNode<Unity.Animation.KernelPassThroughNodeFloat, float, Unity.Animation.KernelPassThroughNodeFloat.Kernel> data, ref Unity.Animation.KernelPassThroughNode<Unity.Animation.KernelPassThroughNodeFloat, float, Unity.Animation.KernelPassThroughNodeFloat.Kernel> ports);
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Mixers", @"Blends animation streams based on an ordered layer approach. Each layer can blend in either override or additive mode. Weight masks can be built using the WeightBuilderNode.", false)] [Unity.DataFlowGraph.Attributes.PortGroupDefinition(@"Number of layers", 1, 2, -1, @"LayerCount")] public class LayerMixerNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.LayerMixerNode.Data, Unity.Animation.LayerMixerNode.SimPorts, Unity.Animation.LayerMixerNode.KernelData, Unity.Animation.LayerMixerNode.KernelDefs, Unity.Animation.LayerMixerNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<System.UInt16>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public LayerMixerNode() {}
        protected virtual void Destroy(Unity.DataFlowGraph.NodeHandle handle);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref System.UInt16 layerCount);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.LayerMixerNode.KernelData, Unity.Animation.LayerMixerNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.LayerMixerNode.KernelData data, ref Unity.Animation.LayerMixerNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public int LayerCount;
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Blending Mode", @"Type of blending to apply", false, 1, 0, 0, true, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.LayerMixerNode, Unity.Animation.BlendingMode>> BlendingModes;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Input", @"Animation stream to blend", false, 1, , 0, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.LayerMixerNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>>> Inputs;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.LayerMixerNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Weight Mask", @"Channel specific weights which are also modulated by the layer weight", false, 1, , 0, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.LayerMixerNode, Unity.DataFlowGraph.Buffer<Unity.Animation.WeightData>>> WeightMasks;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Weight", @"Layer weight", false, 1, 1, 0, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.LayerMixerNode, float>> Weights;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.LayerMixerNode, System.UInt16> LayerCount;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.LayerMixerNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"", @"", true)] public class LoopNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.LoopNode.Data, Unity.Animation.LoopNode.SimPorts, Unity.Animation.LoopNode.KernelData, Unity.Animation.LoopNode.KernelDefs, Unity.Animation.LoopNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<int>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public LoopNode() {}
        protected virtual void Destroy(Unity.DataFlowGraph.NodeHandle handle);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref int msg);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
            public Unity.DataFlowGraph.NodeHandle<Unity.Animation.AddPoseNode> AddNode;
            public Unity.DataFlowGraph.NodeHandle<Unity.Animation.KernelPassThroughNodeFloat> DefaultWeightNode;
            public Unity.DataFlowGraph.NodeHandle<Unity.Animation.InversePoseNode> InverseNode;
            public Unity.DataFlowGraph.NodeHandle<Unity.Animation.SimPassThroughNode<Unity.Animation.Rig>> RigNode;
            public Unity.DataFlowGraph.NodeHandle<Unity.Animation.FloatMulNode> RootWeightNode;
            public Unity.DataFlowGraph.NodeHandle<Unity.Animation.WeightBuilderNode> WeightChannelsNode;
            public Unity.DataFlowGraph.NodeHandle<Unity.Animation.WeightPoseNode> WeightNode;
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.LoopNode.KernelData, Unity.Animation.LoopNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.LoopNode.KernelData data, ref Unity.Animation.LoopNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            public Unity.DataFlowGraph.DataInput<Unity.Animation.LoopNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Delta;
            public Unity.DataFlowGraph.DataInput<Unity.Animation.LoopNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            public Unity.DataFlowGraph.DataInput<Unity.Animation.LoopNode, float> NormalizedTime;
            public Unity.DataFlowGraph.DataOutput<Unity.Animation.LoopNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            public Unity.DataFlowGraph.DataInput<Unity.Animation.LoopNode, float> RootWeightMultiplier;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            public Unity.DataFlowGraph.MessageInput<Unity.Animation.LoopNode, Unity.Animation.Rig> Rig;
            public Unity.DataFlowGraph.MessageInput<Unity.Animation.LoopNode, int> SkipRoot;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Mixers", @"Blends two animation streams given an input weight value", false)] public class MixerNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.MixerNode.Data, Unity.Animation.MixerNode.SimPorts, Unity.Animation.MixerNode.KernelData, Unity.Animation.MixerNode.KernelDefs, Unity.Animation.MixerNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public MixerNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.MixerNode.KernelData, Unity.Animation.MixerNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.MixerNode.KernelData data, ref Unity.Animation.MixerNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfileMixPose;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream 0", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.MixerNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input0;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream 1", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.MixerNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input1;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.MixerNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Blend weight", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.MixerNode, float> Weight;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.MixerNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Mixers", @"Blends N animation streams together given weights per stream", false)] [Unity.DataFlowGraph.Attributes.PortGroupDefinition(@"Number of animation streams", 1, 2, -1, )] public class NMixerNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.NMixerNode.Data, Unity.Animation.NMixerNode.SimPorts, Unity.Animation.NMixerNode.KernelData, Unity.Animation.NMixerNode.KernelDefs, Unity.Animation.NMixerNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public NMixerNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.NMixerNode.KernelData, Unity.Animation.NMixerNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.NMixerNode.KernelData data, ref Unity.Animation.NMixerNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfileNMixer;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Default Pose", @"Override default animation stream values when sum of weights is less than 1", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.NMixerNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> DefaultPoseInput;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Input", @"Animation stream to blend", false, 1, , 0, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.NMixerNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>>> Inputs;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.NMixerNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Weight", @"Blend weight", false, 1, , 0, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.NMixerNode, float>> Weights;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.NMixerNode, Unity.Animation.Rig> Rig;
        }
    }

    [System.Runtime.CompilerServices.Extension] public static class NodeSetExt
    {
        [System.Runtime.CompilerServices.Extension] public static void Connect<TType, TData>(Unity.DataFlowGraph.NodeSet set, Unity.DataFlowGraph.NodeHandle<TType> from, Unity.DataFlowGraph.DataOutput<TType, TData> port, Unity.DataFlowGraph.NodeHandle<Unity.DataFlowGraph.ComponentNode> to, Unity.DataFlowGraph.NodeSet.ConnectionType type = 0) where TType : Unity.DataFlowGraph.NodeDefinition where TData : System.ValueType, Unity.Entities.IComponentData, new();
        [System.Runtime.CompilerServices.Extension] public static void Connect<TType, TBuffer>(Unity.DataFlowGraph.NodeSet set, Unity.DataFlowGraph.NodeHandle<TType> from, Unity.DataFlowGraph.DataOutput<TType, Unity.DataFlowGraph.Buffer<TBuffer>> port, Unity.DataFlowGraph.NodeHandle<Unity.DataFlowGraph.ComponentNode> to, Unity.DataFlowGraph.NodeSet.ConnectionType type = 0) where TType : Unity.DataFlowGraph.NodeDefinition where TBuffer : System.ValueType, Unity.Entities.IBufferElementData, new();
        [System.Runtime.CompilerServices.Extension] public static void Connect<TType, TData>(Unity.DataFlowGraph.NodeSet set, Unity.DataFlowGraph.NodeHandle<Unity.DataFlowGraph.ComponentNode> from, Unity.DataFlowGraph.NodeHandle<TType> to, Unity.DataFlowGraph.DataInput<TType, TData> port, Unity.DataFlowGraph.NodeSet.ConnectionType type = 0) where TType : Unity.DataFlowGraph.NodeDefinition where TData : System.ValueType, Unity.Entities.IComponentData, new();
        [System.Runtime.CompilerServices.Extension] public static void Connect<TType, TBuffer>(Unity.DataFlowGraph.NodeSet set, Unity.DataFlowGraph.NodeHandle<Unity.DataFlowGraph.ComponentNode> from, Unity.DataFlowGraph.NodeHandle<TType> to, Unity.DataFlowGraph.DataInput<TType, Unity.DataFlowGraph.Buffer<TBuffer>> port, Unity.DataFlowGraph.NodeSet.ConnectionType type = 0) where TType : Unity.DataFlowGraph.NodeDefinition where TBuffer : System.ValueType, Unity.Entities.IBufferElementData, new();
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Time", @"Computes normalized time [0, 1] given an input time and duration", false)] public class NormalizedTimeNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.NormalizedTimeNode.Data, Unity.Animation.NormalizedTimeNode.SimPorts, Unity.Animation.NormalizedTimeNode.KernelData, Unity.Animation.NormalizedTimeNode.KernelDefs, Unity.Animation.NormalizedTimeNode.Kernel>, Unity.DataFlowGraph.IMsgHandler<float>
    {
        public NormalizedTimeNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref float msg);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.NormalizedTimeNode.KernelData, Unity.Animation.NormalizedTimeNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.NormalizedTimeNode.KernelData data, ref Unity.Animation.NormalizedTimeNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public float Duration;
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Unbound time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.NormalizedTimeNode, float> InputTime;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Normalized time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.NormalizedTimeNode, float> OutputTime;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Duration", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.NormalizedTimeNode, float> Duration;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Constraints", @"Parent constraint based on multiple sources", false)] [Unity.DataFlowGraph.Attributes.PortGroupDefinition(@"Source Count", 1, 1, -1, )] public class ParentConstraintNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.ParentConstraintNode.Data, Unity.Animation.ParentConstraintNode.SimPorts, Unity.Animation.ParentConstraintNode.KernelData, Unity.Animation.ParentConstraintNode.KernelDefs, Unity.Animation.ParentConstraintNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.ParentConstraintNode.SetupMessage>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public ParentConstraintNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.ParentConstraintNode.SetupMessage msg);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.ParentConstraintNode.KernelData, Unity.Animation.ParentConstraintNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext ctx, Unity.Animation.ParentConstraintNode.KernelData data, ref Unity.Animation.ParentConstraintNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public int Index;
            public Unity.Mathematics.bool3 LocalRotationAxesMask;
            public Unity.Mathematics.bool3 LocalTranslationAxesMask;
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Constrained animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.ParentConstraintNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.ParentConstraintNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Source Transform Offset", @"Transform offset of source", false, 1, @"identity", 2, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.ParentConstraintNode, Unity.Mathematics.float4x4>> SourceOffsets;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Source Transform", @"Transform of source", false, 1, @"identity", 2, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.ParentConstraintNode, Unity.Mathematics.float4x4>> SourceTx;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Source Weight", @"Weight of source", false, 1, 1, 0, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.ParentConstraintNode, float>> SourceWeights;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Constraint weight", false, -1, 1, 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.ParentConstraintNode, float> Weight;
        }
        public struct SetupMessage
        {
            public int Index;
            public Unity.Mathematics.bool3 LocalRotationAxesMask;
            public Unity.Mathematics.bool3 LocalTranslationAxesMask;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Setup", @"Parent constraint properties", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ParentConstraintNode, Unity.Animation.ParentConstraintNode.SetupMessage> ConstraintSetup;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.ParentConstraintNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Constraints", @"Position constraint based on multiple sources", false)] [Unity.DataFlowGraph.Attributes.PortGroupDefinition(@"Source Count", 1, 1, -1, )] public class PositionConstraintNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.PositionConstraintNode.Data, Unity.Animation.PositionConstraintNode.SimPorts, Unity.Animation.PositionConstraintNode.KernelData, Unity.Animation.PositionConstraintNode.KernelDefs, Unity.Animation.PositionConstraintNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.PositionConstraintNode.SetupMessage>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public PositionConstraintNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.PositionConstraintNode.SetupMessage msg);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.PositionConstraintNode.KernelData, Unity.Animation.PositionConstraintNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext ctx, Unity.Animation.PositionConstraintNode.KernelData data, ref Unity.Animation.PositionConstraintNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public int Index;
            public Unity.Mathematics.bool3 LocalAxesMask;
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Constrained animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.PositionConstraintNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Extra local offset to apply to the constrained bone", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.PositionConstraintNode, Unity.Mathematics.float3> LocalOffset;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.PositionConstraintNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Source Offset", @"Position offset of source", false, 1, , 0, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.PositionConstraintNode, Unity.Mathematics.float3>> SourceOffsets;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Source Position", @"Position of source", false, 1, , 0, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.PositionConstraintNode, Unity.Mathematics.float3>> SourcePositions;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Source Weight", @"Weight of source", false, 1, 1, 0, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.PositionConstraintNode, float>> SourceWeights;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Constraint weight", false, -1, 1, 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.PositionConstraintNode, float> Weight;
        }
        public struct SetupMessage
        {
            public int Index;
            public Unity.Mathematics.bool3 LocalAxesMask;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Setup", @"Position constraint properties", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.PositionConstraintNode, Unity.Animation.PositionConstraintNode.SetupMessage> ConstraintSetup;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.PositionConstraintNode, Unity.Animation.Rig> Rig;
        }
    }

    [System.Runtime.CompilerServices.Extension] public static class ResolvedPortArrayExt
    {
        [System.Runtime.CompilerServices.Extension] public static void CopyTo<TDefinition, TType>(Unity.DataFlowGraph.RenderContext/ResolvedPortArray<TDefinition, TType> src, Unity.Collections.NativeArray<TType> dst) where TDefinition : Unity.DataFlowGraph.NodeDefinition where TType : System.ValueType, new();
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Remaps one animation stream to another given a known remapping table", false)] public class RigRemapperNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.RigRemapperNode.Data, Unity.Animation.RigRemapperNode.SimPorts, Unity.Animation.RigRemapperNode.KernelData, Unity.Animation.RigRemapperNode.KernelDefs, Unity.Animation.RigRemapperNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.IMsgHandler<Unity.Entities.BlobAssetReference<Unity.Animation.RigRemapTable>>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public RigRemapperNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Entities.BlobAssetReference<Unity.Animation.RigRemapTable> remapTable);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.RigRemapperNode.KernelData, Unity.Animation.RigRemapperNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.RigRemapperNode.KernelData data, ref Unity.Animation.RigRemapperNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> DestinationRigDefinition;
            public Unity.Profiling.ProfilerMarker ProfileMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigRemapTable> RemapTable;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> SourceRigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Default Pose", @"Override default animation stream output values. If not provided output animation stream is populated with default values from the rig destination rig definition.", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.RigRemapperNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> DefaultPoseInput;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Animation stream to remap from", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.RigRemapperNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.RigRemapperNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.RigRemapperNode, Unity.Animation.Rig> DestinationRig;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Rig Remap Table", @"Remap table between source and destination rigs", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.RigRemapperNode, Unity.Entities.BlobAssetReference<Unity.Animation.RigRemapTable>> RemapTable;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Source Rig", @"Source rig to remap animation from", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.RigRemapperNode, Unity.Animation.Rig> SourceRig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Root Motion", @"Computes root motion values from a baked clip. Used internally by the UberClipNode.", false)] public class RootMotionFromVelocityNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.RootMotionFromVelocityNode.Data, Unity.Animation.RootMotionFromVelocityNode.SimPorts, Unity.Animation.RootMotionFromVelocityNode.KernelData, Unity.Animation.RootMotionFromVelocityNode.KernelDefs, Unity.Animation.RootMotionFromVelocityNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<float>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public RootMotionFromVelocityNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref float msg);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.RootMotionFromVelocityNode.KernelData, Unity.Animation.RootMotionFromVelocityNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.RootMotionFromVelocityNode.KernelData data, ref Unity.Animation.RootMotionFromVelocityNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfileMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
            public float SampleRate;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"The current delta time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.RootMotionFromVelocityNode, float> DeltaTime;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"The current animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.RootMotionFromVelocityNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream with updated root motion values", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.RootMotionFromVelocityNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.RootMotionFromVelocityNode, Unity.Animation.Rig> Rig;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Clip sample rate", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.RootMotionFromVelocityNode, float> SampleRate;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Root Motion", @"Extracts root motion values from animation stream so these can be used for different operations (i.e store state values in entity components)", false)] public class RootMotionNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.RootMotionNode.Data, Unity.Animation.RootMotionNode.SimPorts, Unity.Animation.RootMotionNode.KernelData, Unity.Animation.RootMotionNode.KernelDefs, Unity.Animation.RootMotionNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public RootMotionNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.RootMotionNode.KernelData, Unity.Animation.RootMotionNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.RootMotionNode.KernelData data, ref Unity.Animation.RootMotionNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfileMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Delta Root Motion Transform", @"Current delta root motion", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.RootMotionNode, Unity.Mathematics.float4x4> DeltaRootX;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"The current animation stream with delta root motion values", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.RootMotionNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream without root motion", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.RootMotionNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Previous Root Motion Transform", @"Previous root motion", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.RootMotionNode, Unity.Mathematics.float4x4> PrevRootX;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Root Motion Transform", @"Current root motion", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.RootMotionNode, Unity.Mathematics.float4x4> RootX;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.RootMotionNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Constraints", @"Rotation constraint based on multiple sources", false)] [Unity.DataFlowGraph.Attributes.PortGroupDefinition(@"Source Count", 1, 1, -1, )] public class RotationConstraintNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.RotationConstraintNode.Data, Unity.Animation.RotationConstraintNode.SimPorts, Unity.Animation.RotationConstraintNode.KernelData, Unity.Animation.RotationConstraintNode.KernelDefs, Unity.Animation.RotationConstraintNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.RotationConstraintNode.SetupMessage>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public RotationConstraintNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.RotationConstraintNode.SetupMessage msg);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.RotationConstraintNode.KernelData, Unity.Animation.RotationConstraintNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext ctx, Unity.Animation.RotationConstraintNode.KernelData data, ref Unity.Animation.RotationConstraintNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public int Index;
            public Unity.Mathematics.bool3 LocalAxesMask;
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Constrained animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.RotationConstraintNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Extra local rotation offset to apply to the constrained bone", false, -1, @"identity", 2, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.RotationConstraintNode, Unity.Mathematics.quaternion> LocalOffset;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.RotationConstraintNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Source Rotation Offset", @"Rotation offset of source", false, 1, @"identity", 2, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.RotationConstraintNode, Unity.Mathematics.quaternion>> SourceOffsets;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Source Rotation", @"Rotation of source", false, 1, @"identity", 2, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.RotationConstraintNode, Unity.Mathematics.quaternion>> SourceRotations;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Source Weight", @"Weight of source", false, 1, 1, 0, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.RotationConstraintNode, float>> SourceWeights;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Constraint weight", false, -1, 1, 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.RotationConstraintNode, float> Weight;
        }
        public struct SetupMessage
        {
            public int Index;
            public Unity.Mathematics.bool3 LocalAxesMask;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Setup", @"Rotation constraint properties", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.RotationConstraintNode, Unity.Animation.RotationConstraintNode.SetupMessage> ConstraintSetup;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.RotationConstraintNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Sets a float value in the AnimationStream", false)] public class SetAnimationStreamFloatNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.SetAnimationStreamFloatNode.Data, Unity.Animation.SetAnimationStreamFloatNode.SimPorts, Unity.Animation.SetAnimationStreamFloatNode.KernelData, Unity.Animation.SetAnimationStreamFloatNode.KernelDefs, Unity.Animation.SetAnimationStreamFloatNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public SetAnimationStreamFloatNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.SetAnimationStreamFloatNode.KernelData, Unity.Animation.SetAnimationStreamFloatNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.SetAnimationStreamFloatNode.KernelData data, ref Unity.Animation.SetAnimationStreamFloatNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Index in stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamFloatNode, int> Index;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamFloatNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.SetAnimationStreamFloatNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Value to set", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamFloatNode, float> Value;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.SetAnimationStreamFloatNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Sets an integer value in the AnimationStream", false)] public class SetAnimationStreamIntNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.SetAnimationStreamIntNode.Data, Unity.Animation.SetAnimationStreamIntNode.SimPorts, Unity.Animation.SetAnimationStreamIntNode.KernelData, Unity.Animation.SetAnimationStreamIntNode.KernelDefs, Unity.Animation.SetAnimationStreamIntNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public SetAnimationStreamIntNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.SetAnimationStreamIntNode.KernelData, Unity.Animation.SetAnimationStreamIntNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.SetAnimationStreamIntNode.KernelData data, ref Unity.Animation.SetAnimationStreamIntNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Index in stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamIntNode, int> Index;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamIntNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.SetAnimationStreamIntNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Value to set", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamIntNode, int> Value;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.SetAnimationStreamIntNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Sets the local to parent information of a bone in the AnimationStream", false)] public class SetAnimationStreamLocalToParentNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.SetAnimationStreamLocalToParentNode.Data, Unity.Animation.SetAnimationStreamLocalToParentNode.SimPorts, Unity.Animation.SetAnimationStreamLocalToParentNode.KernelData, Unity.Animation.SetAnimationStreamLocalToParentNode.KernelDefs, Unity.Animation.SetAnimationStreamLocalToParentNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public SetAnimationStreamLocalToParentNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.SetAnimationStreamLocalToParentNode.KernelData, Unity.Animation.SetAnimationStreamLocalToParentNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.SetAnimationStreamLocalToParentNode.KernelData data, ref Unity.Animation.SetAnimationStreamLocalToParentNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Bone index in stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamLocalToParentNode, int> Index;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamLocalToParentNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Modes to set local to parent information", false, -1, 7, 0, true, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamLocalToParentNode, Unity.Animation.SetAnimationStreamLocalToParentNode.SetFromMode> Mode;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.SetAnimationStreamLocalToParentNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Local to parent rotation", false, -1, @"identity", 2, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamLocalToParentNode, Unity.Mathematics.quaternion> Rotation;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Local to parent scale", false, -1, @"1,1,1", 1, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamLocalToParentNode, Unity.Mathematics.float3> Scale;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Local to parent translation", false, -1, @"zero", 2, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamLocalToParentNode, Unity.Mathematics.float3> Translation;
        }
        public enum SetFromMode
        {
            public const Unity.Animation.SetAnimationStreamLocalToParentNode.SetFromMode Rotation = 2;
            public const Unity.Animation.SetAnimationStreamLocalToParentNode.SetFromMode RotationScale = 6;
            public const Unity.Animation.SetAnimationStreamLocalToParentNode.SetFromMode Scale = 4;
            public const Unity.Animation.SetAnimationStreamLocalToParentNode.SetFromMode Translation = 1;
            public const Unity.Animation.SetAnimationStreamLocalToParentNode.SetFromMode TranslationRotation = 3;
            public const Unity.Animation.SetAnimationStreamLocalToParentNode.SetFromMode TranslationRotationScale = 7;
            public const Unity.Animation.SetAnimationStreamLocalToParentNode.SetFromMode TranslationScale = 5;
            public System.UInt32 value__;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.SetAnimationStreamLocalToParentNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Sets the local to root information of a bone in the AnimationStream", false)] public class SetAnimationStreamLocalToRootNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.SetAnimationStreamLocalToRootNode.Data, Unity.Animation.SetAnimationStreamLocalToRootNode.SimPorts, Unity.Animation.SetAnimationStreamLocalToRootNode.KernelData, Unity.Animation.SetAnimationStreamLocalToRootNode.KernelDefs, Unity.Animation.SetAnimationStreamLocalToRootNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public SetAnimationStreamLocalToRootNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.SetAnimationStreamLocalToRootNode.KernelData, Unity.Animation.SetAnimationStreamLocalToRootNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.SetAnimationStreamLocalToRootNode.KernelData data, ref Unity.Animation.SetAnimationStreamLocalToRootNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Bone index in stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamLocalToRootNode, int> Index;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamLocalToRootNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Modes to set local to root information", false, -1, 3, 0, true, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamLocalToRootNode, Unity.Animation.SetAnimationStreamLocalToRootNode.SetFromMode> Mode;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.SetAnimationStreamLocalToRootNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Local to root rotation", false, -1, @"identity", 2, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamLocalToRootNode, Unity.Mathematics.quaternion> Rotation;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Local to root translation", false, -1, @"zero", 2, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.SetAnimationStreamLocalToRootNode, Unity.Mathematics.float3> Translation;
        }
        public enum SetFromMode
        {
            public const Unity.Animation.SetAnimationStreamLocalToRootNode.SetFromMode Rotation = 2;
            public const Unity.Animation.SetAnimationStreamLocalToRootNode.SetFromMode Translation = 1;
            public const Unity.Animation.SetAnimationStreamLocalToRootNode.SetFromMode TranslationRotation = 3;
            public System.UInt32 value__;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.SetAnimationStreamLocalToRootNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"", @"", true)] public class SimPassThroughNode<T> : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.SimPassThroughNode<T>, Unity.Animation.SimPassThroughNode<T>>, Unity.DataFlowGraph.IMsgHandler<T> where T : System.ValueType, new()
    {
        public SimPassThroughNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref T msg);
        public struct SimPorts<T> : Unity.DataFlowGraph.ISimulationPortDefinition where T : System.ValueType, new()
        {
            public Unity.DataFlowGraph.MessageInput<Unity.Animation.SimPassThroughNode<T>, T> Input;
            public Unity.DataFlowGraph.MessageOutput<Unity.Animation.SimPassThroughNode<T>, T> Output;
        }
        public struct Data<T> : Unity.DataFlowGraph.INodeData where T : System.ValueType, new()
        {
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Time", @"Accumulates and output's current time based on scale and delta time", false)] public class TimeCounterNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.TimeCounterNode.Data, Unity.Animation.TimeCounterNode.SimPorts, Unity.Animation.TimeCounterNode.KernelData, Unity.Animation.TimeCounterNode.KernelDefs, Unity.Animation.TimeCounterNode.Kernel>, Unity.DataFlowGraph.IMsgHandler<float>
    {
        public TimeCounterNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref float msg);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        protected virtual void OnUpdate(Unity.DataFlowGraph.UpdateContext& modreq(System.Runtime.InteropServices.InAttribute) ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
            public int SetTime;
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.TimeCounterNode.KernelData, Unity.Animation.TimeCounterNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.TimeCounterNode.KernelData data, ref Unity.Animation.TimeCounterNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfileTimeCounter;
            public int SetTime;
            public float Time;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Delta time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.TimeCounterNode, float> DeltaTime;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting delta time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.TimeCounterNode, float> OutputDeltaTime;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Time Scale", @"Delta time scale factor", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.TimeCounterNode, float> Speed;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.TimeCounterNode, float> Time;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Set internal time to this value", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.TimeCounterNode, float> Time;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Time", @"Computes looping time and cycle count given a duration and unbound time", false)] public class TimeLoopNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.TimeLoopNode.Data, Unity.Animation.TimeLoopNode.SimPorts, Unity.Animation.TimeLoopNode.KernelData, Unity.Animation.TimeLoopNode.KernelDefs, Unity.Animation.TimeLoopNode.Kernel>, Unity.DataFlowGraph.IMsgHandler<float>
    {
        public TimeLoopNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref float msg);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.TimeLoopNode.KernelData, Unity.Animation.TimeLoopNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.TimeLoopNode.KernelData data, ref Unity.Animation.TimeLoopNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public float Duration;
            public Unity.Profiling.ProfilerMarker ProfileTimeLoop;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Number of duration cycles", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.TimeLoopNode, int> Cycle;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Unbound time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.TimeLoopNode, float> InputTime;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Normalized time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.TimeLoopNode, float> NormalizedTime;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Time (computed from normalized time mutiplied by duration)", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.TimeLoopNode, float> OutputTime;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Duration", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.TimeLoopNode, float> Duration;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Constraints", @"Twist correction is mainly used to redistribute a percentage of the source rotation over a leaf bone in order to correct mesh deformation artifacts.", false)] [Unity.DataFlowGraph.Attributes.PortGroupDefinition(@"Twist Bone Count", 1, 1, -1, )] public class TwistCorrectionNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.TwistCorrectionNode.Data, Unity.Animation.TwistCorrectionNode.SimPorts, Unity.Animation.TwistCorrectionNode.KernelData, Unity.Animation.TwistCorrectionNode.KernelDefs, Unity.Animation.TwistCorrectionNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public TwistCorrectionNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.TwistCorrectionNode.KernelData, Unity.Animation.TwistCorrectionNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext ctx, Unity.Animation.TwistCorrectionNode.KernelData data, ref Unity.Animation.TwistCorrectionNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Constrained animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.TwistCorrectionNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Local Twist Axis", false, -1, 1, 0, true, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.TwistCorrectionNode, Unity.Animation.TwistCorrectionNode.TwistAxis> LocalTwistAxis;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.TwistCorrectionNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Source Default Rotation", @"Default or initial rotation of the source at setup. This is used to compute the delta twist rotation", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.TwistCorrectionNode, Unity.Mathematics.quaternion> SourceDefaultRotation;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Source Rotation", @"Current rotation of the source", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.TwistCorrectionNode, Unity.Mathematics.quaternion> SourceRotation;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Twist Bone Index", @"Twist bones driven by the source", false, 1, -1, 0, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.TwistCorrectionNode, int>> TwistIndices;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Twist Bone Weight", @"Twist bone weights", false, 1, 0, 0, false, -1, 1)] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.TwistCorrectionNode, float>> TwistWeights;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Constraint Weight", false, -1, 1, 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.TwistCorrectionNode, float> Weight;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.TwistCorrectionNode, Unity.Animation.Rig> Rig;
        }
        public enum TwistAxis
        {
            public int value__;
            public const Unity.Animation.TwistCorrectionNode.TwistAxis X = 0;
            public const Unity.Animation.TwistCorrectionNode.TwistAxis Y = 1;
            public const Unity.Animation.TwistCorrectionNode.TwistAxis Z = 2;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Constraints", @"Two bone IK solver", false)] public class TwoBoneIKNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.TwoBoneIKNode.Data, Unity.Animation.TwoBoneIKNode.SimPorts, Unity.Animation.TwoBoneIKNode.KernelData, Unity.Animation.TwoBoneIKNode.KernelDefs, Unity.Animation.TwoBoneIKNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.TwoBoneIKNode.SetupMessage>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public TwoBoneIKNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.TwoBoneIKNode.SetupMessage msg);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.TwoBoneIKNode.KernelData, Unity.Animation.TwoBoneIKNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext ctx, Unity.Animation.TwoBoneIKNode.KernelData data, ref Unity.Animation.TwoBoneIKNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public int MidIndex;
            public Unity.Profiling.ProfilerMarker ProfilerMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
            public int RootIndex;
            public Unity.Mathematics.RigidTransform TargetOffset;
            public int TipIndex;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Target hint position", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.TwoBoneIKNode, Unity.Mathematics.float3> Hint;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"IK hint weight", false, -1, 0, 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.TwoBoneIKNode, float> HintWeight;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Constrained animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.TwoBoneIKNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.TwoBoneIKNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Target transform", false, -1, @"identity", 2, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.TwoBoneIKNode, Unity.Mathematics.float4x4> Target;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"IK goal position weight", false, -1, 1, 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.TwoBoneIKNode, float> TargetPositionWeight;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"IK goal rotation weight", false, -1, 1, 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.TwoBoneIKNode, float> TargetRotationWeight;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Constraint weight", false, -1, 1, 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.TwoBoneIKNode, float> Weight;
        }
        public struct SetupMessage
        {
            public int MidIndex;
            public int RootIndex;
            public Unity.Mathematics.RigidTransform TargetOffset;
            public int TipIndex;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Setup", @"Two bone IK properties", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.TwoBoneIKNode, Unity.Animation.TwoBoneIKNode.SetupMessage> ConstraintSetup;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.TwoBoneIKNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core", @"Clip node that can perform different actions based on clip configuration data and supports root motion", true)] public class UberClipNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.UberClipNode.Data, Unity.Animation.UberClipNode.SimPorts, Unity.Animation.UberClipNode.KernelData, Unity.Animation.UberClipNode.KernelDefs, Unity.Animation.UberClipNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<bool>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.ClipConfiguration>, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.IMsgHandler<Unity.Entities.BlobAssetReference<Unity.Animation.Clip>>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public UberClipNode() {}
        public static Unity.Entities.BlobAssetReference<Unity.Animation.Clip> Bake(Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rig, Unity.Entities.BlobAssetReference<Unity.Animation.Clip> sourceClip, Unity.Animation.ClipConfiguration clipConfiguration, float sampleRate = 60);
        public static Unity.Entities.BlobAssetReference<Unity.Animation.Clip> Bake(Unity.DataFlowGraph.NodeSet set, Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> rig, Unity.Entities.BlobAssetReference<Unity.Animation.Clip> sourceClip, Unity.Animation.ClipConfiguration clipConfiguration, float sampleRate = 60);
        protected virtual void Destroy(Unity.DataFlowGraph.NodeHandle handle);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref bool msg);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.ClipConfiguration msg);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Entities.BlobAssetReference<Unity.Animation.Clip> clip);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
            public Unity.Entities.BlobAssetReference<Unity.Animation.Clip> Clip;
            public bool IsAdditive;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.UberClipNode.KernelData, Unity.Animation.UberClipNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.UberClipNode.KernelData data, ref Unity.Animation.UberClipNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Delta time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.UberClipNode, float> DeltaTime;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting animation stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.UberClipNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Unbound time", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.UberClipNode, float> Time;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Is this an additive clip", false, -1, false, 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.UberClipNode, bool> Additive;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Clip to sample", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.UberClipNode, Unity.Entities.BlobAssetReference<Unity.Animation.Clip>> Clip;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Clip configuration data", false, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.UberClipNode, Unity.Animation.ClipConfiguration> Configuration;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.UberClipNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Creates weight masks based on passed channel indices and weights", false)] [Unity.DataFlowGraph.Attributes.PortGroupDefinition(@"Number of channels", 1, 1, -1, )] public class WeightBuilderNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.WeightBuilderNode.Data, Unity.Animation.WeightBuilderNode.SimPorts, Unity.Animation.WeightBuilderNode.KernelData, Unity.Animation.WeightBuilderNode.KernelDefs, Unity.Animation.WeightBuilderNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public WeightBuilderNode() {}
        protected virtual void Destroy(Unity.DataFlowGraph.NodeHandle handle);
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.WeightBuilderNode.KernelData, Unity.Animation.WeightBuilderNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.WeightBuilderNode.KernelData data, ref Unity.Animation.WeightBuilderNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Channel Index", @"Channel index in rig definition", false, 1, , 0, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.WeightBuilderNode, int>> ChannelIndices;
            [Unity.DataFlowGraph.Attributes.PortDefinition(@"Channel Weight", @"Weight value for this channel", false, 1, , 0, false, , )] public Unity.DataFlowGraph.PortArray<Unity.DataFlowGraph.DataInput<Unity.Animation.WeightBuilderNode, float>> ChannelWeights;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Default weight that is applied to all channels", false, -1, 1, 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.WeightBuilderNode, float> DefaultWeight;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting weight data", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.WeightBuilderNode, Unity.DataFlowGraph.Buffer<Unity.Animation.WeightData>> Output;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.WeightBuilderNode, Unity.Animation.Rig> Rig;
        }
    }

    [Unity.DataFlowGraph.Attributes.NodeDefinition(@"Animation Core/Utils", @"Applies a set of weights to an animation stream", false)] public class WeightPoseNode : Unity.DataFlowGraph.NodeDefinition<Unity.Animation.WeightPoseNode.Data, Unity.Animation.WeightPoseNode.SimPorts, Unity.Animation.WeightPoseNode.KernelData, Unity.Animation.WeightPoseNode.KernelDefs, Unity.Animation.WeightPoseNode.Kernel>, Unity.Animation.IRigContextHandler, Unity.DataFlowGraph.IMsgHandler<Unity.Animation.Rig>, Unity.DataFlowGraph.ITaskPort<Unity.Animation.IRigContextHandler>, Unity.DataFlowGraph.ITaskPortMsgHandler<Unity.Animation.IRigContextHandler, Unity.Animation.Rig>
    {
        public WeightPoseNode() {}
        public void HandleMessage(ref Unity.DataFlowGraph.MessageContext ctx, ref Unity.Animation.Rig rig);
        protected virtual void Init(Unity.DataFlowGraph.InitContext ctx);
        public struct Data : Unity.DataFlowGraph.INodeData
        {
        }
        [Unity.Burst.BurstCompile] public struct Kernel : Unity.DataFlowGraph.IGraphKernel, Unity.DataFlowGraph.IGraphKernel<Unity.Animation.WeightPoseNode.KernelData, Unity.Animation.WeightPoseNode.KernelDefs>
        {
            public virtual void Execute(Unity.DataFlowGraph.RenderContext context, Unity.Animation.WeightPoseNode.KernelData data, ref Unity.Animation.WeightPoseNode.KernelDefs ports);
        }
        public struct KernelData : Unity.DataFlowGraph.IKernelData
        {
            public Unity.Profiling.ProfilerMarker ProfileMarker;
            public Unity.Entities.BlobAssetReference<Unity.Animation.RigDefinition> RigDefinition;
        }
        public struct KernelDefs : Unity.DataFlowGraph.IKernelPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Input stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.WeightPoseNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Input;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Resulting weighted stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataOutput<Unity.Animation.WeightPoseNode, Unity.DataFlowGraph.Buffer<Unity.Animation.AnimatedData>> Output;
            [Unity.DataFlowGraph.Attributes.PortDefinition(, @"Weights to apply on stream", false, -1, , 0, false, , )] public Unity.DataFlowGraph.DataInput<Unity.Animation.WeightPoseNode, Unity.DataFlowGraph.Buffer<Unity.Animation.WeightData>> WeightMasks;
        }
        public struct SimPorts : Unity.DataFlowGraph.ISimulationPortDefinition
        {
            [Unity.DataFlowGraph.Attributes.PortDefinition(, , true, -1, , 0, false, , )] public Unity.DataFlowGraph.MessageInput<Unity.Animation.WeightPoseNode, Unity.Animation.Rig> Rig;
        }
    }
}

namespace Unity.DataFlowGraph.Attributes
{
    public enum DefaultValueType
    {
        public const Unity.DataFlowGraph.Attributes.DefaultValueType ComplexValue = 1;
        public const Unity.DataFlowGraph.Attributes.DefaultValueType Reference = 2;
        public const Unity.DataFlowGraph.Attributes.DefaultValueType Value = 0;
        public int value__;
    }

    [System.AttributeUsage(4)] public class NodeDefinitionAttribute : System.Attribute
    {
        public string Category { get; }
        public bool IsHidden { get; }
        public string NodeDescription { get; }
        public NodeDefinitionAttribute(string category = , string description = , bool isHidden = False) {}
    }

    [System.AttributeUsage(256)] public class PortDefinitionAttribute : System.Attribute
    {
        public object DefaultValue { get; }
        public Unity.DataFlowGraph.Attributes.DefaultValueType DefaultValueType { get; }
        public string Description { get; }
        public string DisplayName { get; }
        public bool IsHidden { get; }
        public bool IsStatic { get; }
        public object MaxValueUI { get; }
        public object MinValueUI { get; }
        public int PortGroupIndex { get; }
        public PortDefinitionAttribute(string displayName = default(string), string description = default(string), bool isHidden = False, int portGroupIndex = -1, object defaultValue = default(object), Unity.DataFlowGraph.Attributes.DefaultValueType defaultValueType = 0, bool isStatic = False, object minValueUI = default(object), object maxValueUI = default(object)) {}
    }

    [System.AttributeUsage(4)] public class PortGroupDefinitionAttribute : System.Attribute
    {
        public int MaxInstance { get; }
        public int MinInstance { get; }
        public int PortGroupIndex { get; }
        public string PortGroupSizeDescription { get; }
        public string SimulationPortToDrive { get; }
        public PortGroupDefinitionAttribute(string portGroupSizeDescription, int groupIndex, int minInstance = 0, int maxInstance = -1, string simulationPortToDrive = default(string)) {}
    }
}
